{
    "docs": [
        {
            "location": "/about/",
            "text": "About\n\n\nWhat is guizero?\n\n\n\n\nIt is a Python 3 library for creating simple GUIs\n\n\nIt is a wrapper for the standard Tkinter library (included by default when Python is installed)\n\n\n\n\nAims\n\n\nThe aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for new learners.\n\n\n\n\nWorks with standard Python Tkinter GUI library (and no need to install other libraries)\n\n\nAbstracts away details new learners find difficult to understand (such as Tkinter StringVar() objects)\n\n\nAccessible widget naming system to help new learners to build up a mental model\n\n\nFlexible enough to be used for projects up to A-Level standard, yet accessible to primary school children\n\n\nComprehensive and accessible documentation with examples\n\n\nGenerates helpful additional error messages\n\n\n\n\nVersion\n\n\nguizero is currently \nversion 0.6.0\n\n\nThere may be bugs and features may change and be updated.",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/about/#what-is-guizero",
            "text": "It is a Python 3 library for creating simple GUIs  It is a wrapper for the standard Tkinter library (included by default when Python is installed)",
            "title": "What is guizero?"
        },
        {
            "location": "/about/#aims",
            "text": "The aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for new learners.   Works with standard Python Tkinter GUI library (and no need to install other libraries)  Abstracts away details new learners find difficult to understand (such as Tkinter StringVar() objects)  Accessible widget naming system to help new learners to build up a mental model  Flexible enough to be used for projects up to A-Level standard, yet accessible to primary school children  Comprehensive and accessible documentation with examples  Generates helpful additional error messages",
            "title": "Aims"
        },
        {
            "location": "/about/#version",
            "text": "guizero is currently  version 0.6.0  There may be bugs and features may change and be updated.",
            "title": "Version"
        },
        {
            "location": "/",
            "text": "Installation\n\n\nguizero is designed to allow new learners to quickly and easily create GUIs for their programs.\n\n\nIf you can download and unzip a file, you can \ninstall guizero\n - \nno special permissions or administrator rights are required\n.\n\n\nIf you have administrator rights and are connected to the internet, you can use \npip to quickly install guizero\n.\n\n\nguizero only requires \ntkinter\n to be installed, which is included with a standard Python installation on all platforms except Linux.\n\n\nEasy installation\n\n\n\n\n\n\nGo to the \nGithub repo\n for guizero\n\n\n\n\n\n\nClick the green \"Clone or download\" button and then \"Download ZIP\"\n\n\n\n\n\n\n\n\nUnzip the file\n\n\n\n\n\n\nOpen the \nguizero-master\n folder, then copy the \nguizero\n folder and paste it into your home directory\n\n\n\n\n\n\n\n\nThat's it! When you write your guizero code, make sure you save it into your home directory.\n\n\n\n\n\n\nInstall using pip\n\n\nWindows\n\n\n\n\nMake sure you have \npip\n installed.\n\n\nOpen a command prompt\n\n\nType \npip install guizero\n and press Enter\n\n\n\n\nRaspberry Pi\n\n\n\n\nOpen a terminal window\n\n\nType \nsudo pip3 install guizero\n and press Enter\n\n\n\n\nMac OS\n\n\n\n\n\n\nOpen a terminal (you can search for it in the Launch Pad)\n\n\n\n\n\n\n\n\nType \nsudo pip3 install guizero\n\n\n\n\n\n\n\n\nLinux\n\n\n\n\nOpen a terminal\n\n\nInstall \ntkinter\n using your distribution's package manager, e.g. \nsudo apt install python3-tk\n\n\nInstall guizero using pip by typing \npip3 install guizero\n or \nsudo pip3 install guizero\n if you dont have superuser rights",
            "title": "Installation"
        },
        {
            "location": "/#installation",
            "text": "guizero is designed to allow new learners to quickly and easily create GUIs for their programs.  If you can download and unzip a file, you can  install guizero  -  no special permissions or administrator rights are required .  If you have administrator rights and are connected to the internet, you can use  pip to quickly install guizero .  guizero only requires  tkinter  to be installed, which is included with a standard Python installation on all platforms except Linux.",
            "title": "Installation"
        },
        {
            "location": "/#easy-installation",
            "text": "Go to the  Github repo  for guizero    Click the green \"Clone or download\" button and then \"Download ZIP\"     Unzip the file    Open the  guizero-master  folder, then copy the  guizero  folder and paste it into your home directory     That's it! When you write your guizero code, make sure you save it into your home directory.",
            "title": "Easy installation"
        },
        {
            "location": "/#install-using-pip",
            "text": "",
            "title": "Install using pip"
        },
        {
            "location": "/#windows",
            "text": "Make sure you have  pip  installed.  Open a command prompt  Type  pip install guizero  and press Enter",
            "title": "Windows"
        },
        {
            "location": "/#raspberry-pi",
            "text": "Open a terminal window  Type  sudo pip3 install guizero  and press Enter",
            "title": "Raspberry Pi"
        },
        {
            "location": "/#mac-os",
            "text": "Open a terminal (you can search for it in the Launch Pad)     Type  sudo pip3 install guizero",
            "title": "Mac OS"
        },
        {
            "location": "/#linux",
            "text": "Open a terminal  Install  tkinter  using your distribution's package manager, e.g.  sudo apt install python3-tk  Install guizero using pip by typing  pip3 install guizero  or  sudo pip3 install guizero  if you dont have superuser rights",
            "title": "Linux"
        },
        {
            "location": "/start/",
            "text": "Getting Started\n\n\nAt the start of every guizero program, choose the widgets you need from the guizero library and import them:\n\n\nfrom guizero import App, PushButton, Slider\n\n\n\n\nYou only need to import each widget once, and then you can use it in your program as many times as you like.\n\n\nHello World\n\n\nAll guizero projects begin with a main window which is called an \nApp\n. At the end of every guizero program you must tell the program to display the app you have just created.\n\n\nLet's create an app window with the title \"Hello world\":\n\n\nfrom guizero import App\napp = App(title=\"Hello world\")\napp.display()\n\n\n\n\nSave and run the code - you've created your first guizero app!\n\n\nAdding widgets\n\n\nWidgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.\n\n\nAll widgets\n go between the line of code to create the \nApp\n and the \napp.display()\n line.\n\n\nfrom guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()\n\n\n\n\n\n\nLet\u2019s look at the \nText\n widget code in a bit more detail:\n\n\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\n\n\n\n\n\n\nmessage =\n - The \nText\n object has a name, just like any variable\n\n\nText\n - an \nobject\n which creates a piece of text on the screen\n\n\napp\n \u2013 This tells the \nText\n where it will live. Most of the time your widgets will live directly inside the app.\n\n\ntext=\"Welcome to the Hello world app!\"\n - The text to display\n\n\n\n\nAnd that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Getting started"
        },
        {
            "location": "/start/#getting-started",
            "text": "At the start of every guizero program, choose the widgets you need from the guizero library and import them:  from guizero import App, PushButton, Slider  You only need to import each widget once, and then you can use it in your program as many times as you like.",
            "title": "Getting Started"
        },
        {
            "location": "/start/#hello-world",
            "text": "All guizero projects begin with a main window which is called an  App . At the end of every guizero program you must tell the program to display the app you have just created.  Let's create an app window with the title \"Hello world\":  from guizero import App\napp = App(title=\"Hello world\")\napp.display()  Save and run the code - you've created your first guizero app!",
            "title": "Hello World"
        },
        {
            "location": "/start/#adding-widgets",
            "text": "Widgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.  All widgets  go between the line of code to create the  App  and the  app.display()  line.  from guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()   Let\u2019s look at the  Text  widget code in a bit more detail:  message = Text(app, text=\"Welcome to the Hello world app!\")   message =  - The  Text  object has a name, just like any variable  Text  - an  object  which creates a piece of text on the screen  app  \u2013 This tells the  Text  where it will live. Most of the time your widgets will live directly inside the app.  text=\"Welcome to the Hello world app!\"  - The text to display   And that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Adding widgets"
        },
        {
            "location": "/commands/",
            "text": "Commands\n\n\nWidgets in guizero can be given a \ncommand\n when created, which can be used to call a function when the widget is used.\n\n\nBy using commands you can make your GUI change and take actions when the user uses it e.g. clicking a button, selecting an option, typing a message. \n\n\nExample\n\n\nCreate an application which puts \nhello world\n on the GUI when a button is pressed:\n\n\nfrom guizero import App, Text, PushButton\n\ndef say_hello():\n    text.value = \"hello world\"\n\napp = App()\ntext = Text(app)\nbutton = PushButton(app, command=say_hello)\napp.display()",
            "title": "Commands"
        },
        {
            "location": "/commands/#commands",
            "text": "Widgets in guizero can be given a  command  when created, which can be used to call a function when the widget is used.  By using commands you can make your GUI change and take actions when the user uses it e.g. clicking a button, selecting an option, typing a message.",
            "title": "Commands"
        },
        {
            "location": "/commands/#example",
            "text": "Create an application which puts  hello world  on the GUI when a button is pressed:  from guizero import App, Text, PushButton\n\ndef say_hello():\n    text.value = \"hello world\"\n\napp = App()\ntext = Text(app)\nbutton = PushButton(app, command=say_hello)\napp.display()",
            "title": "Example"
        },
        {
            "location": "/multiple_windows/",
            "text": "Multiple Windows\n\n\nA guizero application should only have have 1 \nApp\n object, this is the main window and controller of your program.\n\n\nIf you want to create a 2nd (or 3rd, 4th, 5th) window, your program should use a \nWindow\n object.\n\n\nA 2nd Window\n\n\nCreating a 2nd Window is easy and just like creating a widget you need to pass it the App:\n\n\nfrom guizero import App, Window\n\napp = App(title=\"Main window\")\nwindow = Window(app, title=\"2nd window\")\n\napp.display()\n\n\n\n\n\nAdding widgets to the 2nd window is the same as adding them to an app, by passing the name of the window:\n\n\nfrom guizero import App, Window, Text\n\napp = App(title=\"Main window\")\nwindow = Window(app, title=\"2nd window\")\ntext = Text(window, text=\"text\")\n\napp.display()\n\n\n\n\n\nOpening and closing windows\n\n\nWhen a \nWindow\n object is created it is immediately displayed on the screen, you can control it using the \nshow()\n and \nhide()\n methods.\n\n\nTo make a window which is shown when a button on the \nApp\n is clicked and closed when a button is clicked on the \nWindow\n.\n\n\nfrom guizero import App, Window\n\ndef open_window():\n    window.show()\n\ndef close_window():\n    window.hide()\n\napp = App(title=\"Main window\")\n\nwindow = Window(app, title=\"2nd window\")\nwindow.hide()\n\nopen_button = PushButton(app, text=\"Open\", command=open_window)\nclose_button = PushButton(window, text=\"Close\", command=close_window)\n\napp.display()\n\n\n\n\nModal windows\n\n\nWhen a window is opened using \nshow()\n it is opening side by side with the main window, and both windows can be used at the same time\n\n\nTo open a \"modal\" window which prevents the other windows in the applcation being used until it is closed you can pass \nTrue\n to the optional \nwait\n parameter of \nshow\n e.g. \nwindow.show(wait=True)\n.\n\n\nThis will force all other windows to wait until this window is closed before they can be used.\n\n\ndef open_window():\n    window.show(wait=True)",
            "title": "Multiple windows"
        },
        {
            "location": "/multiple_windows/#multiple-windows",
            "text": "A guizero application should only have have 1  App  object, this is the main window and controller of your program.  If you want to create a 2nd (or 3rd, 4th, 5th) window, your program should use a  Window  object.",
            "title": "Multiple Windows"
        },
        {
            "location": "/multiple_windows/#a-2nd-window",
            "text": "Creating a 2nd Window is easy and just like creating a widget you need to pass it the App:  from guizero import App, Window\n\napp = App(title=\"Main window\")\nwindow = Window(app, title=\"2nd window\")\n\napp.display()  Adding widgets to the 2nd window is the same as adding them to an app, by passing the name of the window:  from guizero import App, Window, Text\n\napp = App(title=\"Main window\")\nwindow = Window(app, title=\"2nd window\")\ntext = Text(window, text=\"text\")\n\napp.display()",
            "title": "A 2nd Window"
        },
        {
            "location": "/multiple_windows/#opening-and-closing-windows",
            "text": "When a  Window  object is created it is immediately displayed on the screen, you can control it using the  show()  and  hide()  methods.  To make a window which is shown when a button on the  App  is clicked and closed when a button is clicked on the  Window .  from guizero import App, Window\n\ndef open_window():\n    window.show()\n\ndef close_window():\n    window.hide()\n\napp = App(title=\"Main window\")\n\nwindow = Window(app, title=\"2nd window\")\nwindow.hide()\n\nopen_button = PushButton(app, text=\"Open\", command=open_window)\nclose_button = PushButton(window, text=\"Close\", command=close_window)\n\napp.display()",
            "title": "Opening and closing windows"
        },
        {
            "location": "/multiple_windows/#modal-windows",
            "text": "When a window is opened using  show()  it is opening side by side with the main window, and both windows can be used at the same time  To open a \"modal\" window which prevents the other windows in the applcation being used until it is closed you can pass  True  to the optional  wait  parameter of  show  e.g.  window.show(wait=True) .  This will force all other windows to wait until this window is closed before they can be used.  def open_window():\n    window.show(wait=True)",
            "title": "Modal windows"
        },
        {
            "location": "/layout/",
            "text": "Layouts\n\n\nThe layout of your GUI is how you arrange the widgets in the window.\n\n\nWidgets can be arranged into \"containers\" (e.g. \nApp\n, \nWindow\n, \nBox\n) using either of these layouts:\n\n\n\n\nauto\n - where widgets are positioned automatically\n\n\ngrid\n - you specify where in a grid each widget should be positioned\n\n\n\n\nThe layout is set using \nlayout\n parameter of the container e.g.\n\n\napp = App(layout=\"auto\")\napp = App(layout=\"grid\")\n\n\n\n\nIf no \nlayout\n parameter is specified, the default \nauto\n layout is used.\n\n\nAuto layout\n\n\nauto\n is the default layout used when a container is created. All widgets will be arranged in the order they are created and aligned to the centre, e.g. the following code will create two Text widgets, one on top of the other.\n\n\nfrom guizero import App, Text\napp = App()\ntext_1 = Text(app, text=\"on top\")\ntext_2 = Text(app, text=\"below\")\napp.display()\n\n\n\n\n\n\nAligning\n\n\nWidgets can be aligned to either the \ntop\n, \nbottom\n, \nleft\n or \nright\n, using the \nalign\n property when created.\n\n\nAligning Widgets will cause them to be \"stuck\" to that side of the container e.g.\n\n\nfrom guizero import App, Text\napp = App()\ntop_text = Text(app, text=\"at the top\", align=\"top\")\nbottom_text = Text(app, text=\"at the bottom\", align=\"bottom\")\nleft_text = Text(app, text=\"to the left\", align=\"left\")\nright_text = Text(app, text=\"to the right\", align=\"right\")\napp.display()\n\n\n\n\n\n\nBy aligning multiple widgets to the same side of the container, widgets can be made to stack together e.g.\n\n\nfrom guizero import App, Text, TextBox, PushButton\napp = App()\ntext = Text(app, text=\"label\", align=\"left\")\ntext_box = TextBox(app, text=\"enter text\", align=\"left\")\nbutton = PushButton(app, text=\"submit\", align=\"left\")\napp.display()\n\n\n\n\n\n\nThe widgets will stack in the order they are created, so the widget created first will be closest to the edge in the direction specified.\n\n\nFilling\n\n\nWidgets can also be made to \"fill\" all the available space by setting the \nwidth\n and \nheight\n parameters to \nfill\n.\n\n\ne.g.\n\n\nA TextBox could span the entire width of the container:\n\n\nfrom guizero import App, TextBox\napp = App()\ntext_box = TextBox(app, text=\"enter text\", width=\"fill\")\napp.display()\n\n\n\n\n\n\nOr a ListBox could fill the left hand side by using \nfill\n for the \nheight\n and \nalign\n to the \nleft\n e.g.\n\n\nfrom guizero import App, ListBox\napp = App()\nlist_box = ListBox(app, items=[\"a list\"], height=\"fill\", align=\"left\")\napp.display()\n\n\n\n\n\n\nUsing \nfill\n for the \nwidth\n and the \nheight\n will make a widget use all the available space e.g.\n\n\nfrom guizero import App, PushButton\napp = App()\nbutton = PushButton(app, width=\"fill\", height=\"fill\")\napp.display()\n\n\n\n\n\n\nWhen multiple widgets use \nfill\n the Window Manager (operating system) will distribute the space accordingly between all the widgets which need to fill it.\n\n\nfrom guizero import App, ListBox, PushButton\napp = App()\nlist_box = ListBox(app, items=[\"a list\", \"of items\", \"yay\"], height=\"fill\", align=\"left\")\nbutton = PushButton(app, width=\"fill\", height=\"fill\", align=\"right\")\napp.display()\n\n\n\n\n\n\nNote :\n Using fill may not always have the effect you are expecting as it is up to the operating system to distribute screen space.\n\n\nGrid layout\n\n\nThe \ngrid\n layout allows you to position widgets into a virtual grid.\n\n\nWhen you create a widget you will need to pass an extra parameter called \ngrid\n which is a list containing \n[x,y]\n coordinates for where you want the widget to appear, like this:\n\n\napp = App(layout=\"grid\")\ntext = Text(app, text=\"Hello world\", grid=[0,1])\n\n\n\n\nThere is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.\n\n\nThis is really useful when creating GUIs where you want widgets to line up.\n\n\ne.g.\n\n\nCreating a number keypad:\n\n\n\n\nfrom guizero import App, PushButton\n\napp = App(layout=\"grid\")\n\nbutton1 = PushButton(app, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, text=\"2\", grid=[1,0])\nbutton3  = PushButton(app, text=\"3\", grid=[2,0])\nbutton4  = PushButton(app, text=\"4\", grid=[0,1])\nbutton5  = PushButton(app, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, text=\"6\", grid=[2,1])\nbutton7  = PushButton(app, text=\"7\", grid=[0,2])\nbutton8  = PushButton(app, text=\"8\", grid=[1,2])\nbutton9  = PushButton(app, text=\"9\", grid=[2,2])\nbutton0  = PushButton(app, text=\"0\", grid=[1,3])\n\napp.display()\n\n\n\n\nYou can also align widgets within the grid, e.g. when you are creating a form:\n\n\n\n\nfrom guizero import App, Text, TextBox\n\napp = App(layout=\"grid\")\n\nname_label = Text(app, text=\"Name\", grid=[0,0], align=\"left\")\nname = TextBox(app, grid=[1,0])\nsurname_label = Text(app, text=\"Surname\", grid=[0,1], align=\"left\")\nsurname = TextBox(app, grid=[1,1])\ndob_label = Text(app, text=\"Date of Birth\", grid=[0,2], align=\"left\")\ndob = TextBox(app, grid=[1,2])\n\napp.display()\n\n\n\n\nSpanning columns or rows\n\n\nWidgets can be made to span multiple columns or rows by specifying the span within the grid parameter. These are optional, but if specified both must be included using the format \n[x,y,xspan,yspan]\n.\n\n\nThe example below shows text widget located at 0,1 spanning two columns (x) and one row (y):\n\n\ntext = Text(app, text=\"Hello world\", grid=[0,1,2,1])\n\n\n\n\nThis can be used to include widgets of different sizes arranged alongside each other.\n\n\nfrom guizero import App, Picture\n\napp = App(layout=\"grid\")\n\npicture1 = Picture(app, image=\"std1.gif\", grid=[0,0])\npicture2 = Picture(app, image=\"std2.gif\", grid=[1,0])\npicture3 = Picture(app, image=\"tall1.gif\", grid=[2,0,1,2])\npicture4 = Picture(app, image=\"wide1.gif\", grid=[0,1,2,1])\n\napp.display()\n\n\n\n\n\n\nBoxes\n\n\nBy using a \nBox\n widget you can segment your GUI into different sections allowing you to lay out your user interface in any way you want.\n\n\n\n\ncode for example above\n\n\nIf you wanted to create a title in the top left hand corner of your GUI, you could use a \nBox\n which fills the top of the \nApp\n and put a \nText\n widget inside aligned to the \nleft\n.\n\n\nfrom guizero import App, Box, Text\napp = App()\n\ntitle_box = Box(app, width=\"fill\", align=\"top\")\ntitle = Text(title_box, text=\"title\", align=\"left\")\n\napp.display()\n\n\n\n\n\n\nYou may find it easier to design your layout if your Boxes have borders, which can be done by setting the \nborder\n parameter on \nBox\n to \nTrue\n.\n\n\ntitle_box = Box(app, width=\"fill\", align=\"top\", border=True)\n\n\n\n\n\n\nA similar method can be used to put \"OK\" and \"Cancel\" buttons at the bottom right of the GUI. Remember that the widgets will get stacked on the right in order of creation, so the cancel button is created first.\n\n\nfrom guizero import App, Box, PushButton\napp = App()\n\nbuttons_box = Box(app, width=\"fill\", align=\"bottom\")\ncancel = PushButton(buttons_box, text=\"Cancel\", align=\"right\")\nok = PushButton(buttons_box, text=\"OK\", align=\"right\")\n\napp.display()\n\n\n\n\n\n\nNote :\n A \nBox\n can also be contained in a \nBox\n, allowing you to layer boxes and position your widgets.\n\n\nTip :\n When creating a GUI you may find it easier to design it first on paper, noting where your boxes will be positioned.",
            "title": "Layouts"
        },
        {
            "location": "/layout/#layouts",
            "text": "The layout of your GUI is how you arrange the widgets in the window.  Widgets can be arranged into \"containers\" (e.g.  App ,  Window ,  Box ) using either of these layouts:   auto  - where widgets are positioned automatically  grid  - you specify where in a grid each widget should be positioned   The layout is set using  layout  parameter of the container e.g.  app = App(layout=\"auto\")\napp = App(layout=\"grid\")  If no  layout  parameter is specified, the default  auto  layout is used.",
            "title": "Layouts"
        },
        {
            "location": "/layout/#auto-layout",
            "text": "auto  is the default layout used when a container is created. All widgets will be arranged in the order they are created and aligned to the centre, e.g. the following code will create two Text widgets, one on top of the other.  from guizero import App, Text\napp = App()\ntext_1 = Text(app, text=\"on top\")\ntext_2 = Text(app, text=\"below\")\napp.display()",
            "title": "Auto layout"
        },
        {
            "location": "/layout/#aligning",
            "text": "Widgets can be aligned to either the  top ,  bottom ,  left  or  right , using the  align  property when created.  Aligning Widgets will cause them to be \"stuck\" to that side of the container e.g.  from guizero import App, Text\napp = App()\ntop_text = Text(app, text=\"at the top\", align=\"top\")\nbottom_text = Text(app, text=\"at the bottom\", align=\"bottom\")\nleft_text = Text(app, text=\"to the left\", align=\"left\")\nright_text = Text(app, text=\"to the right\", align=\"right\")\napp.display()   By aligning multiple widgets to the same side of the container, widgets can be made to stack together e.g.  from guizero import App, Text, TextBox, PushButton\napp = App()\ntext = Text(app, text=\"label\", align=\"left\")\ntext_box = TextBox(app, text=\"enter text\", align=\"left\")\nbutton = PushButton(app, text=\"submit\", align=\"left\")\napp.display()   The widgets will stack in the order they are created, so the widget created first will be closest to the edge in the direction specified.",
            "title": "Aligning"
        },
        {
            "location": "/layout/#filling",
            "text": "Widgets can also be made to \"fill\" all the available space by setting the  width  and  height  parameters to  fill .  e.g.  A TextBox could span the entire width of the container:  from guizero import App, TextBox\napp = App()\ntext_box = TextBox(app, text=\"enter text\", width=\"fill\")\napp.display()   Or a ListBox could fill the left hand side by using  fill  for the  height  and  align  to the  left  e.g.  from guizero import App, ListBox\napp = App()\nlist_box = ListBox(app, items=[\"a list\"], height=\"fill\", align=\"left\")\napp.display()   Using  fill  for the  width  and the  height  will make a widget use all the available space e.g.  from guizero import App, PushButton\napp = App()\nbutton = PushButton(app, width=\"fill\", height=\"fill\")\napp.display()   When multiple widgets use  fill  the Window Manager (operating system) will distribute the space accordingly between all the widgets which need to fill it.  from guizero import App, ListBox, PushButton\napp = App()\nlist_box = ListBox(app, items=[\"a list\", \"of items\", \"yay\"], height=\"fill\", align=\"left\")\nbutton = PushButton(app, width=\"fill\", height=\"fill\", align=\"right\")\napp.display()   Note :  Using fill may not always have the effect you are expecting as it is up to the operating system to distribute screen space.",
            "title": "Filling"
        },
        {
            "location": "/layout/#grid-layout",
            "text": "The  grid  layout allows you to position widgets into a virtual grid.  When you create a widget you will need to pass an extra parameter called  grid  which is a list containing  [x,y]  coordinates for where you want the widget to appear, like this:  app = App(layout=\"grid\")\ntext = Text(app, text=\"Hello world\", grid=[0,1])  There is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.  This is really useful when creating GUIs where you want widgets to line up.  e.g.  Creating a number keypad:   from guizero import App, PushButton\n\napp = App(layout=\"grid\")\n\nbutton1 = PushButton(app, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, text=\"2\", grid=[1,0])\nbutton3  = PushButton(app, text=\"3\", grid=[2,0])\nbutton4  = PushButton(app, text=\"4\", grid=[0,1])\nbutton5  = PushButton(app, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, text=\"6\", grid=[2,1])\nbutton7  = PushButton(app, text=\"7\", grid=[0,2])\nbutton8  = PushButton(app, text=\"8\", grid=[1,2])\nbutton9  = PushButton(app, text=\"9\", grid=[2,2])\nbutton0  = PushButton(app, text=\"0\", grid=[1,3])\n\napp.display()  You can also align widgets within the grid, e.g. when you are creating a form:   from guizero import App, Text, TextBox\n\napp = App(layout=\"grid\")\n\nname_label = Text(app, text=\"Name\", grid=[0,0], align=\"left\")\nname = TextBox(app, grid=[1,0])\nsurname_label = Text(app, text=\"Surname\", grid=[0,1], align=\"left\")\nsurname = TextBox(app, grid=[1,1])\ndob_label = Text(app, text=\"Date of Birth\", grid=[0,2], align=\"left\")\ndob = TextBox(app, grid=[1,2])\n\napp.display()",
            "title": "Grid layout"
        },
        {
            "location": "/layout/#spanning-columns-or-rows",
            "text": "Widgets can be made to span multiple columns or rows by specifying the span within the grid parameter. These are optional, but if specified both must be included using the format  [x,y,xspan,yspan] .  The example below shows text widget located at 0,1 spanning two columns (x) and one row (y):  text = Text(app, text=\"Hello world\", grid=[0,1,2,1])  This can be used to include widgets of different sizes arranged alongside each other.  from guizero import App, Picture\n\napp = App(layout=\"grid\")\n\npicture1 = Picture(app, image=\"std1.gif\", grid=[0,0])\npicture2 = Picture(app, image=\"std2.gif\", grid=[1,0])\npicture3 = Picture(app, image=\"tall1.gif\", grid=[2,0,1,2])\npicture4 = Picture(app, image=\"wide1.gif\", grid=[0,1,2,1])\n\napp.display()",
            "title": "Spanning columns or rows"
        },
        {
            "location": "/layout/#boxes",
            "text": "By using a  Box  widget you can segment your GUI into different sections allowing you to lay out your user interface in any way you want.   code for example above  If you wanted to create a title in the top left hand corner of your GUI, you could use a  Box  which fills the top of the  App  and put a  Text  widget inside aligned to the  left .  from guizero import App, Box, Text\napp = App()\n\ntitle_box = Box(app, width=\"fill\", align=\"top\")\ntitle = Text(title_box, text=\"title\", align=\"left\")\n\napp.display()   You may find it easier to design your layout if your Boxes have borders, which can be done by setting the  border  parameter on  Box  to  True .  title_box = Box(app, width=\"fill\", align=\"top\", border=True)   A similar method can be used to put \"OK\" and \"Cancel\" buttons at the bottom right of the GUI. Remember that the widgets will get stacked on the right in order of creation, so the cancel button is created first.  from guizero import App, Box, PushButton\napp = App()\n\nbuttons_box = Box(app, width=\"fill\", align=\"bottom\")\ncancel = PushButton(buttons_box, text=\"Cancel\", align=\"right\")\nok = PushButton(buttons_box, text=\"OK\", align=\"right\")\n\napp.display()   Note :  A  Box  can also be contained in a  Box , allowing you to layer boxes and position your widgets.  Tip :  When creating a GUI you may find it easier to design it first on paper, noting where your boxes will be positioned.",
            "title": "Boxes"
        },
        {
            "location": "/alerts/",
            "text": "Alerts\n\n\nAlerts are pop-up windows which can be used to interupt the user by asking question or providing information.\n\n\n\n\nUsing alerts\n\n\nTo use the alerts you will need to import each one individually at the start of your program. For example:\n\n\nfrom guizero import warn, info\n\n\n\n\nPurpose\n\n\nThese functions pop up a box on the screen that displays a message. The functions available are:\n\n\n\n\nwarn(title, text)\n - popup box with a warning icon\n\n\ninfo(title, text)\n - popup box with an information icon\n\n\nerror(title, text)\n - popup box with an error icon\n\n\nyesno(title, text)\n - popup box with yes and no options. Pressing \nYes\n returns \nTrue\n and pressing \nNo\n returns \nFalse\n.\n\n\n\n\nAll pop up boxes use the native display, so they will look different depending on your operating system.\n\n\nExamples\n\n\nWarning box\n\n\nThis will pop up a warning box with the title \n\"Uh oh!\"\n and the message \n\"You are almost out of biscuits!\"\n.\n\n\nfrom guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()\n\n\n\n\nOn Windows, the box looks like this:\n\n\n\n\nThe \ninfo\n and \nerror\n boxes work in exactly the same way but will display different icons.\n\n\nYes/No box\n\n\nWhen this function is called it returns a \nboolean\n value.\n\n\n\n\nIf \nYes\n was pressed, return \nTrue\n\n\nIf \nNo\n was pressed, return \nFalse\n\n\n\n\nYou can store this value in a variable and test it:\n\n\nfrom guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()\n\n\n\n\nThis code will first display the yes/no box\n\n\n\n\nIf \nYes\n is pressed, an information box will be displayed:\n\n\n\n\nIf \nNo\n is pressed, an error box will be displayed\n\n\n\n\nExample: Using an alert as a callback\n\n\nYou can also use these functions in a \ncallback\n (when you have to provide a function for another widget to call). Here is an example with a \nPushButton\n which pops up an \ninfo\n box when it is pressed.\n\n\nfrom guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()\n\n\n\n\nThe arguments provided to the \nPushButton\n are:\n\n\n\n\nWhere the button should be created (within the \napp\n)\n\n\nThe name of the function to call when pressed (\ninfo\n)\n\n\nA list of the arguments to the function you are calling (values for the \ntitle\n and \nmessage\n arguments for the \ninfo\n function)\n\n\n\n\nExample: Do you really want to close?\n\n\nYou can use a \nyesno\n box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.\n\n\nfrom guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#alerts",
            "text": "Alerts are pop-up windows which can be used to interupt the user by asking question or providing information.",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#using-alerts",
            "text": "To use the alerts you will need to import each one individually at the start of your program. For example:  from guizero import warn, info",
            "title": "Using alerts"
        },
        {
            "location": "/alerts/#purpose",
            "text": "These functions pop up a box on the screen that displays a message. The functions available are:   warn(title, text)  - popup box with a warning icon  info(title, text)  - popup box with an information icon  error(title, text)  - popup box with an error icon  yesno(title, text)  - popup box with yes and no options. Pressing  Yes  returns  True  and pressing  No  returns  False .   All pop up boxes use the native display, so they will look different depending on your operating system.",
            "title": "Purpose"
        },
        {
            "location": "/alerts/#examples",
            "text": "Warning box  This will pop up a warning box with the title  \"Uh oh!\"  and the message  \"You are almost out of biscuits!\" .  from guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()  On Windows, the box looks like this:   The  info  and  error  boxes work in exactly the same way but will display different icons.  Yes/No box  When this function is called it returns a  boolean  value.   If  Yes  was pressed, return  True  If  No  was pressed, return  False   You can store this value in a variable and test it:  from guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()  This code will first display the yes/no box   If  Yes  is pressed, an information box will be displayed:   If  No  is pressed, an error box will be displayed   Example: Using an alert as a callback  You can also use these functions in a  callback  (when you have to provide a function for another widget to call). Here is an example with a  PushButton  which pops up an  info  box when it is pressed.  from guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()  The arguments provided to the  PushButton  are:   Where the button should be created (within the  app )  The name of the function to call when pressed ( info )  A list of the arguments to the function you are calling (values for the  title  and  message  arguments for the  info  function)   Example: Do you really want to close?  You can use a  yesno  box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.  from guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/size/",
            "text": "Sizes\n\n\nYou can set the \nwidth\n and \nheight\n of widgets in guizero.\n\n\nWidgets are sized by pixels or characters depending on the widget and what it contains.\n\n\nSome widgets size can also be set to \n\"fill\"\n where it will use up all of the available space.\n\n\nfrom guizero import App, PushButton, Slider, ListBox\n\napp = App()\n\n# a PushButton's size is noted in characters\nbutton = PushButton(app, width=30, height=5)\n\n# a Slider's size is noted in pixels\nslider = Slider(app, width=300, height=30)\n\n# some widgets, such as ListBox can also be told to fill all the available space\nlistbox = ListBox(app, width=\"fill\", height=\"fill\")\n\napp.display()\n\n\n\n\n\n\n\n\n\n\nWidget\n\n\nCharacters or Pixels\n\n\nFill\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBox\n\n\nPixels\n\n\nYes\n\n\nIf a Box is sized in Pixels, both width and height must be specified.\n\n\n\n\n\n\nButtonGroup\n\n\nCharacters\n\n\nYes\n\n\nThe height of a ButtonGroup must divide by the number of buttons in it\n\n\n\n\n\n\nCheckBox\n\n\nCharacters\n\n\nYes\n\n\n\n\n\n\n\n\nCombo\n\n\nCharacters\n\n\nYes\n\n\n\n\n\n\n\n\nListBox\n\n\nCharacters\n\n\nYes\n\n\n\n\n\n\n\n\nPicture\n\n\nPixels\n\n\nNo\n\n\nSee \nImages\n for more information\n\n\n\n\n\n\nPushButton\n\n\nCharacters\n\n\nYes\n\n\n\n\n\n\n\n\nPushButton\n with image\n\n\nPixels\n\n\nNo\n\n\nPushButton's which have images are sized in pixels\n\n\n\n\n\n\nSlider\n\n\nPixels\n\n\nYes\n\n\n\n\n\n\n\n\nText\n\n\nCharacters\n\n\nYes\n\n\n\n\n\n\n\n\nTextBox\n\n\nCharacters\n\n\nYes\n\n\nOnly a TextBox's width can be set\n\n\n\n\n\n\nWaffle\n\n\nPixels\n\n\nNo",
            "title": "Sizes"
        },
        {
            "location": "/size/#sizes",
            "text": "You can set the  width  and  height  of widgets in guizero.  Widgets are sized by pixels or characters depending on the widget and what it contains.  Some widgets size can also be set to  \"fill\"  where it will use up all of the available space.  from guizero import App, PushButton, Slider, ListBox\n\napp = App()\n\n# a PushButton's size is noted in characters\nbutton = PushButton(app, width=30, height=5)\n\n# a Slider's size is noted in pixels\nslider = Slider(app, width=300, height=30)\n\n# some widgets, such as ListBox can also be told to fill all the available space\nlistbox = ListBox(app, width=\"fill\", height=\"fill\")\n\napp.display()     Widget  Characters or Pixels  Fill  Notes      Box  Pixels  Yes  If a Box is sized in Pixels, both width and height must be specified.    ButtonGroup  Characters  Yes  The height of a ButtonGroup must divide by the number of buttons in it    CheckBox  Characters  Yes     Combo  Characters  Yes     ListBox  Characters  Yes     Picture  Pixels  No  See  Images  for more information    PushButton  Characters  Yes     PushButton  with image  Pixels  No  PushButton's which have images are sized in pixels    Slider  Pixels  Yes     Text  Characters  Yes     TextBox  Characters  Yes  Only a TextBox's width can be set    Waffle  Pixels  No",
            "title": "Sizes"
        },
        {
            "location": "/colors/",
            "text": "Colors (or Colo\nu\nrs)\n\n\nYou can set colors in guizero using:\n\n\n\n\nthe name of the color - \nwhite\n\n\na #rgb hex value - \n#ffffff\n\n\na list of rgb values - \n(255,255,255)\n \n\n\n\n\nColors can be used as either starting parameters e.g. :\n\n\napp = App(bg = \"red\")\napp = App(bg = \"#ff0000\")\napp = App(bg = (255, 0, 0))\n\n\n\n\nor as properties e.g. :\n\n\ntext = Text(app, text = \"hi\")\ntext.text_color = \"green\"\ntext.text_color = \"#00ff00\"\ntext.text_color = (0, 255, 0)\n\n\n\n\nIf a color is set using a list of rgb values (\n(255,255,255)\n) it will be returned as an #rgb hex value (\n#ffffff\n)\n\n\nColor names\n\n\nColor names can be given as strings e.g.\n\n\n\n\nwhite\n\n\nblack\n\n\nred\n\n\ngreen\n\n\nblue\n\n\nyellow\n\n\n\n\nA complete list of color names is available at \nwiki.tcl.tk/37701\n\n\nrgb hex value\n\n\nA rgb color value must start with a \n#\n and 6 characters following, 2 each for the red, green and blue value in hex. Each value must be \n00\n - \nff\n e.g.\n\n\n\n\nwhite = \n#ffffff\n\n\nblack = \n#000000\n\n\nred = \n#ff0000\n\n\ngreen = \n#00ff00\n\n\nblue = \n#0000ff\n\n\nyellow = \n#ffff00\n\n\n\n\nYou can mix your own color by changing the red, green and blue values. \n\n\nThere is a RGB calculator application at \nhttps://www.w3schools.com/colors/colors_rgb.asp\n where you can create your own color and get the \n#rrggbb\n value.\n\n\nrgb list\n\n\nThe \n(red, green, blue)\n list color, must have 3 elements in the order red, green, blue with values 0 - 255 e.g.\n\n\n\n\nwhite = (255, 255, 255)\n\n\nblack = (0, 0, 0)\n\n\nred = (255, 0, 0)\n\n\ngreen = (0, 255, 0)\n\n\nblue = (0, 0, 255)\n\n\nyellow = (255, 255, 0)",
            "title": "Colors"
        },
        {
            "location": "/colors/#colors-or-colours",
            "text": "You can set colors in guizero using:   the name of the color -  white  a #rgb hex value -  #ffffff  a list of rgb values -  (255,255,255)     Colors can be used as either starting parameters e.g. :  app = App(bg = \"red\")\napp = App(bg = \"#ff0000\")\napp = App(bg = (255, 0, 0))  or as properties e.g. :  text = Text(app, text = \"hi\")\ntext.text_color = \"green\"\ntext.text_color = \"#00ff00\"\ntext.text_color = (0, 255, 0)  If a color is set using a list of rgb values ( (255,255,255) ) it will be returned as an #rgb hex value ( #ffffff )",
            "title": "Colors (or Colours)"
        },
        {
            "location": "/colors/#color-names",
            "text": "Color names can be given as strings e.g.   white  black  red  green  blue  yellow   A complete list of color names is available at  wiki.tcl.tk/37701",
            "title": "Color names"
        },
        {
            "location": "/colors/#rgb-hex-value",
            "text": "A rgb color value must start with a  #  and 6 characters following, 2 each for the red, green and blue value in hex. Each value must be  00  -  ff  e.g.   white =  #ffffff  black =  #000000  red =  #ff0000  green =  #00ff00  blue =  #0000ff  yellow =  #ffff00   You can mix your own color by changing the red, green and blue values.   There is a RGB calculator application at  https://www.w3schools.com/colors/colors_rgb.asp  where you can create your own color and get the  #rrggbb  value.",
            "title": "rgb hex value"
        },
        {
            "location": "/colors/#rgb-list",
            "text": "The  (red, green, blue)  list color, must have 3 elements in the order red, green, blue with values 0 - 255 e.g.   white = (255, 255, 255)  black = (0, 0, 0)  red = (255, 0, 0)  green = (0, 255, 0)  blue = (0, 0, 255)  yellow = (255, 255, 0)",
            "title": "rgb list"
        },
        {
            "location": "/images/",
            "text": "Images\n\n\nWidgets such as \nPicture\n and \nPushButton\n allow you to use images in your GUI.\n\n\nfrom guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()\n\n\n\n\nThe types of image (GIF, JPG, PNG, etc) supported depend on how you \ninstalled guizero\n and the setup of your computer.\n\n\nSupported files types\n\n\nAll systems support the \nGIF\n file type.\n\n\nWindows and Linux also support \nPNG\n files.\n\n\nIf you \ninstalled guizero\n using \npip\n it will also have installed \nPIL\n (Python Imaging Library) and you will be able use the majority of commonly used image types.\n\n\nguizero will tell you what file types are supported on your computer using the following code:\n\n\nfrom guizero import system_config\nprint(system_config.supported_image_types)\n\n\n\n\n\n\n\n\n\n\nOperating System\n\n\nPIL NOT available\n\n\nPIL available\n\n\n\n\n\n\n\n\n\n\nWindows\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nMacOS\n\n\nGIF\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nLinux\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nRaspbian\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\n\n\nResizing\n\n\nWhen the size of a widget is changed the image will be changed to fit the widget, if \nPIL\n is available the image will be scaled correctly, if not the image will be cropped.\n\n\nAnimated GIFs\n\n\nIf \nPIL\n is installed guizero supports displaying animated GIFs, if not, the GIF will be displayed as a static image.",
            "title": "Images"
        },
        {
            "location": "/images/#images",
            "text": "Widgets such as  Picture  and  PushButton  allow you to use images in your GUI.  from guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()  The types of image (GIF, JPG, PNG, etc) supported depend on how you  installed guizero  and the setup of your computer.",
            "title": "Images"
        },
        {
            "location": "/images/#supported-files-types",
            "text": "All systems support the  GIF  file type.  Windows and Linux also support  PNG  files.  If you  installed guizero  using  pip  it will also have installed  PIL  (Python Imaging Library) and you will be able use the majority of commonly used image types.  guizero will tell you what file types are supported on your computer using the following code:  from guizero import system_config\nprint(system_config.supported_image_types)     Operating System  PIL NOT available  PIL available      Windows  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    MacOS  GIF  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    Linux  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    Raspbian  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF",
            "title": "Supported files types"
        },
        {
            "location": "/images/#resizing",
            "text": "When the size of a widget is changed the image will be changed to fit the widget, if  PIL  is available the image will be scaled correctly, if not the image will be cropped.",
            "title": "Resizing"
        },
        {
            "location": "/images/#animated-gifs",
            "text": "If  PIL  is installed guizero supports displaying animated GIFs, if not, the GIF will be displayed as a static image.",
            "title": "Animated GIFs"
        },
        {
            "location": "/blocking/",
            "text": "Loops and sleeping\n\n\nYou may be used to writing programs which contain loops or make use of the \nsleep()\n command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an \nevent driven\n model of programming which may be different to the one you are familiar with.\n\n\nYour first guizero program might look a bit like this:\n\n\nfrom guizero import App\napp = App(\"Hello world\")\napp.display()\n\n\n\n\nThe line of code \napp.display()\n doesn't just display the app - it enters an \ninfinite event loop\n which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.\n\n\nExample\n\n\nSuppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:\n\n\nfrom guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()\n\n\n\n\nIf you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:\n\n\n\n\n\n\nThe \nsleep()\n command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.\n\n\n\n\n\n\nThe \nwhile\n loop - once you enter this loop, your GUI will never update ever again and will probably crash.\n\n\n\n\n\n\nSolution\n\n\nThis behaviour is not a bug within guizero or tkinter.\n\n\nYou must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:\n\n\n\n\n\n\nWrite a function which performs the desired action (in this example \ncounter()\n)\n\n\n\n\n\n\nSet a \ncallback\n to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example \n1000\n), or you can schedule it only once.\n\n\n\n\n\n\nfrom guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#loops-and-sleeping",
            "text": "You may be used to writing programs which contain loops or make use of the  sleep()  command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an  event driven  model of programming which may be different to the one you are familiar with.  Your first guizero program might look a bit like this:  from guizero import App\napp = App(\"Hello world\")\napp.display()  The line of code  app.display()  doesn't just display the app - it enters an  infinite event loop  which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#example",
            "text": "Suppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:  from guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()  If you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:    The  sleep()  command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.    The  while  loop - once you enter this loop, your GUI will never update ever again and will probably crash.",
            "title": "Example"
        },
        {
            "location": "/blocking/#solution",
            "text": "This behaviour is not a bug within guizero or tkinter.  You must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:    Write a function which performs the desired action (in this example  counter() )    Set a  callback  to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example  1000 ), or you can schedule it only once.    from guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Solution"
        },
        {
            "location": "/events/",
            "text": "Events\n\n\nWarning - events are currently experimental, issues maybe experienced and the API may change.\n.\n\n\nCustom events can be added to guizero widgets to call functions when the user takes the following actions:\n\n\n\n\nwhen clicked - \nwhen_clicked\n\n\nwhen the left mouse button is pressed - \nwhen_left_button_pressed\n\n\nwhen the left mouse button is released - \nwhen_left_button_released\n\n\nwhen the right mouse button is pressed - \nwhen_right_button_pressed\n\n\nwhen the right mouse button is released - \nwhen_right_button_released\n\n\nwhen a key is pressed - \nwhen_key_pressed\n\n\nwhen a key is released - \nwhen_key_released\n\n\nwhen the mouse enters a widget - \nwhen_mouse_enters\n\n\nwhen the mouse leaves a widget - \nwhen_mouse_leaves\n\n\nwhen the mouse is dragged across a widget - \nwhen_mouse_dragged\n\n\n\n\nEvents are set by assigning them to a function:\n\n\ndef clicked():\n    print(\"clicked\")\n\nwidget.when_clicked = clicked\n\n\n\n\nEvent Data\n\n\nThe function which is called can also accept a parameter and will be passed data about the event which occured.\n\n\nThe event data returned has:\n\n\n\n\nwidget\n - the guizero widget which raised the event\n\n\ntk_event\n - the \ntkinter event object\n\n\nkey\n - the key which raised the event\n\n\nx\n - the mouse's x position relative to the widget when the event occured\n\n\ny\n - the mouse's y position relative to the widget when the event occured\n\n\ndisplay_x\n - the mouse's x position on the display when the event occured\n\n\ndisplay_y\n - the mouse's y position on the display when the event occured\n\n\n\n\ndef clicked(event_data):\n    print(\"widget clicked = \" + event_data.widget)\n    print(\"mouse position = \" + event_data.x + \".\" + event_data.y)\n\nwidget.when_clicked = clicked\n\n\n\n\nExample\n\n\nHighlight a text box widget by changing its background color (\nbg\n) when the mouse is hovering over it.\n\n\nfrom guizero import App, TextBox\n\ndef highlight():\n    text_box.bg = \"lightblue\"\n\ndef lowlight():\n    text_box.bg = \"white\"\n\napp = App()\ntext_box = TextBox(app)\n\n# when the mouse enters the textbox\ntext_box.when_mouse_enters = highlight\n# when the mouse leaves the textbox\ntext_box.when_mouse_leaves = lowlight\n\napp.display()",
            "title": "Events"
        },
        {
            "location": "/events/#events",
            "text": "Warning - events are currently experimental, issues maybe experienced and the API may change. .  Custom events can be added to guizero widgets to call functions when the user takes the following actions:   when clicked -  when_clicked  when the left mouse button is pressed -  when_left_button_pressed  when the left mouse button is released -  when_left_button_released  when the right mouse button is pressed -  when_right_button_pressed  when the right mouse button is released -  when_right_button_released  when a key is pressed -  when_key_pressed  when a key is released -  when_key_released  when the mouse enters a widget -  when_mouse_enters  when the mouse leaves a widget -  when_mouse_leaves  when the mouse is dragged across a widget -  when_mouse_dragged   Events are set by assigning them to a function:  def clicked():\n    print(\"clicked\")\n\nwidget.when_clicked = clicked",
            "title": "Events"
        },
        {
            "location": "/events/#event-data",
            "text": "The function which is called can also accept a parameter and will be passed data about the event which occured.  The event data returned has:   widget  - the guizero widget which raised the event  tk_event  - the  tkinter event object  key  - the key which raised the event  x  - the mouse's x position relative to the widget when the event occured  y  - the mouse's y position relative to the widget when the event occured  display_x  - the mouse's x position on the display when the event occured  display_y  - the mouse's y position on the display when the event occured   def clicked(event_data):\n    print(\"widget clicked = \" + event_data.widget)\n    print(\"mouse position = \" + event_data.x + \".\" + event_data.y)\n\nwidget.when_clicked = clicked",
            "title": "Event Data"
        },
        {
            "location": "/events/#example",
            "text": "Highlight a text box widget by changing its background color ( bg ) when the mouse is hovering over it.  from guizero import App, TextBox\n\ndef highlight():\n    text_box.bg = \"lightblue\"\n\ndef lowlight():\n    text_box.bg = \"white\"\n\napp = App()\ntext_box = TextBox(app)\n\n# when the mouse enters the textbox\ntext_box.when_mouse_enters = highlight\n# when the mouse leaves the textbox\ntext_box.when_mouse_leaves = lowlight\n\napp.display()",
            "title": "Example"
        },
        {
            "location": "/usingtk/",
            "text": "Using tkinter methods\n\n\nIf you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.\n\n\nEach guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero \nTextBox\n contains a tkinter \nEntry\n object. You can always access the internal object using the syntax \n<object_name>.tk\n.\n\n\nUsing a tkinter method on a guizero object\n\n\nIn this example, we have guizero \nApp\n and \nTextBox\n widgets.\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\napp.display()\n\n\n\n\nYou want to make the mouse cursor change when you are over the text box, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using \n<object_name>.tk\n and then you call the tkinter method:\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(cursor=\"target\")    # config() is a tkinter method\napp.display()\n\n\n\n\nYou can combine the use of \nguizero\n and \ntkinter\n seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-tkinter-methods",
            "text": "If you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.  Each guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero  TextBox  contains a tkinter  Entry  object. You can always access the internal object using the syntax  <object_name>.tk .",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-a-tkinter-method-on-a-guizero-object",
            "text": "In this example, we have guizero  App  and  TextBox  widgets.  from guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\napp.display()  You want to make the mouse cursor change when you are over the text box, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using  <object_name>.tk  and then you call the tkinter method:  from guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(cursor=\"target\")    # config() is a tkinter method\napp.display()  You can combine the use of  guizero  and  tkinter  seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using a tkinter method on a guizero object"
        },
        {
            "location": "/gettinghelp/",
            "text": "Getting help\n\n\nYou may encounter a problem when using guizero, so here are some ways you can get help to solve your problem.\n\n\nGetting help\n\n\nIf you have a question about your guizero program it is a good idea to join a community to ask for support:\n\n\n\n\nRaspberry Pi Forums\n - some people post questions about guizero on these forums and other members of the community step in to help. The creators of guizero periodically check the Python forum.\n\n\nStack Overflow\n - a popular site for techy questions\n\n\nComputing at School\n - a useful site for teachers\n\n\n\n\nIf you would like to read guides and resources for guizero there are many freely available:\n\n\n\n\n\n\nExample programs\n - some example programs to get you going.\n\n\n\n\n\n\nUsing guizero with hardware\n - Ben Nuttall's projects using guizero combined with hardware\n\n\n\n\n\n\nGetting started with GUIs\n - a beginners guide to guizero by the Raspberry Pi Foundation\n\n\n\n\n\n\nCat name generator\n - materials for a kids workshop, first run at the \nCotswold Jam\n\n\n\n\n\n\nName your pet\n - article on page 42 of \nHello World\n magazine issue 2.\n\n\n\n\n\n\nBugs and feature requests\n\n\nLike many Python libraries, guizero has a \nGitHub repository\n where you can add issues. These issues come under two headings:\n\n\n\n\nYou found a bug in guizero\n\n\nYou would like to request we consider including a new feature\n\n\n\n\nWe look at and respond to all issues created on GitHub. However, we ask that you only create issues for bugs and feature requests, rather than support, as we do not have time to answer everything :)",
            "title": "Getting help"
        },
        {
            "location": "/gettinghelp/#getting-help",
            "text": "You may encounter a problem when using guizero, so here are some ways you can get help to solve your problem.",
            "title": "Getting help"
        },
        {
            "location": "/gettinghelp/#getting-help_1",
            "text": "If you have a question about your guizero program it is a good idea to join a community to ask for support:   Raspberry Pi Forums  - some people post questions about guizero on these forums and other members of the community step in to help. The creators of guizero periodically check the Python forum.  Stack Overflow  - a popular site for techy questions  Computing at School  - a useful site for teachers   If you would like to read guides and resources for guizero there are many freely available:    Example programs  - some example programs to get you going.    Using guizero with hardware  - Ben Nuttall's projects using guizero combined with hardware    Getting started with GUIs  - a beginners guide to guizero by the Raspberry Pi Foundation    Cat name generator  - materials for a kids workshop, first run at the  Cotswold Jam    Name your pet  - article on page 42 of  Hello World  magazine issue 2.",
            "title": "Getting help"
        },
        {
            "location": "/gettinghelp/#bugs-and-feature-requests",
            "text": "Like many Python libraries, guizero has a  GitHub repository  where you can add issues. These issues come under two headings:   You found a bug in guizero  You would like to request we consider including a new feature   We look at and respond to all issues created on GitHub. However, we ask that you only create issues for bugs and feature requests, rather than support, as we do not have time to answer everything :)",
            "title": "Bugs and feature requests"
        },
        {
            "location": "/recipes/",
            "text": "Recipes\n\n\nThese are examples of how you can use \nguizero\n to create user interfaces. Don't be restricted to these ideas, check out \nUsing guizero\n and the \nwidgets\n.\n\n\nHello World\n\n\nCreate a guizero app and display some text.\n\n\nfrom guizero import App, Text\napp = App()\ntext = Text(app, text=\"hello world\")\napp.display()\n\n\n\n\nGet some text\n\n\nGet some data from the user using a \nTextBox\n.\n\n\nfrom guizero import App, TextBox\n\napp = App()\nname = TextBox(app. text=\"Enter your name\")\n\napp.display()\n\n\n\n\nPush a button\n\n\nUse a \nPushButton\n to display a message when the button is pressed. \n\n\nfrom guizero import App, TextBox, PushButton, Text\n\ndef update_text():\n    label.value = name.value\n\napp = App()\nlabel = Text(app, text=\"What's your name?\")\nname = TextBox(app)\nbutton = PushButton(app, command=update_text)\n\napp.display()\n\n\n\n\nDisplay an image\n\n\nUse a \nPicture\n object to display an image.\n\n\nfrom guizero import App, Picture\napp = App()\npic = Picture(app, image=\"myimage.gif\")\napp.display()\n\n\n\n\nToggle 2 buttons\n\n\nHave 2 buttons, \nstart\n and \nstop\n with them changing the \nenabled\n state of each other.\n\n\nfrom guizero import App, PushButton\n\ndef start():\n    start_button.disable()\n    stop_button.enable()\n\ndef stop():\n    start_button.enable()\n    stop_button.disable()\n\napp = App()\nstart_button = PushButton(app, command=start, text=\"start\")\nstop_button = PushButton(app, command=stop, text=\"stop\", enabled=False)\napp.display()\n\n\n\n\nChange your apps appearance\n\n\nYour app doesn't have to use the standard colors and text, let your user pick the background and text color from 2 combo's.\n\n\nfrom guizero import App, Combo, Text\n\ndef update_bg():\n    app.bg = bg_combo.value\n\ndef update_text():\n    app.text_color = text_combo.value\n\ncolors = [\"black\", \"white\", \"red\", \"green\", \"blue\"]\n\napp = App()\napp.bg = \"black\"\napp.text_color = \"white\"\n\ntitle1 = Text(app, text=\"Background color\")\nbg_combo = Combo(app, options=colors, selected=app.bg, command=update_bg)\n\ntitle2 = Text(app, text=\"Text color\")\ntext_combo = Combo(app, options=colors, selected=app.text_color, command=update_text)\n\napp.display()\n\n\n\n\nScale an image\n\n\nDisplay an image on the screen with 2 sliders, 1 for height and 1 for width.\n\n\nfrom guizero import App, Slider, Picture\n\ndef resize():\n    picture.width = width.value\n    picture.height = height.value\n\napp = App(layout=\"grid\")\n\npicture = Picture(app, image=\"image.gif\", grid=[0,1])\n\nwidth = Slider(app, command=resize, grid=[0,0], start=1, end=picture.width)\nwidth.width = picture.width\nwidth.value = picture.width\n\nheight = Slider(app, command=resize, horizontal=False, grid=[1,1], start=1, end=picture.height)\nheight.height = picture.height\nheight.value = picture.height\n\napp.display()",
            "title": "Recipes"
        },
        {
            "location": "/recipes/#recipes",
            "text": "These are examples of how you can use  guizero  to create user interfaces. Don't be restricted to these ideas, check out  Using guizero  and the  widgets .",
            "title": "Recipes"
        },
        {
            "location": "/recipes/#hello-world",
            "text": "Create a guizero app and display some text.  from guizero import App, Text\napp = App()\ntext = Text(app, text=\"hello world\")\napp.display()",
            "title": "Hello World"
        },
        {
            "location": "/recipes/#get-some-text",
            "text": "Get some data from the user using a  TextBox .  from guizero import App, TextBox\n\napp = App()\nname = TextBox(app. text=\"Enter your name\")\n\napp.display()",
            "title": "Get some text"
        },
        {
            "location": "/recipes/#push-a-button",
            "text": "Use a  PushButton  to display a message when the button is pressed.   from guizero import App, TextBox, PushButton, Text\n\ndef update_text():\n    label.value = name.value\n\napp = App()\nlabel = Text(app, text=\"What's your name?\")\nname = TextBox(app)\nbutton = PushButton(app, command=update_text)\n\napp.display()",
            "title": "Push a button"
        },
        {
            "location": "/recipes/#display-an-image",
            "text": "Use a  Picture  object to display an image.  from guizero import App, Picture\napp = App()\npic = Picture(app, image=\"myimage.gif\")\napp.display()",
            "title": "Display an image"
        },
        {
            "location": "/recipes/#toggle-2-buttons",
            "text": "Have 2 buttons,  start  and  stop  with them changing the  enabled  state of each other.  from guizero import App, PushButton\n\ndef start():\n    start_button.disable()\n    stop_button.enable()\n\ndef stop():\n    start_button.enable()\n    stop_button.disable()\n\napp = App()\nstart_button = PushButton(app, command=start, text=\"start\")\nstop_button = PushButton(app, command=stop, text=\"stop\", enabled=False)\napp.display()",
            "title": "Toggle 2 buttons"
        },
        {
            "location": "/recipes/#change-your-apps-appearance",
            "text": "Your app doesn't have to use the standard colors and text, let your user pick the background and text color from 2 combo's.  from guizero import App, Combo, Text\n\ndef update_bg():\n    app.bg = bg_combo.value\n\ndef update_text():\n    app.text_color = text_combo.value\n\ncolors = [\"black\", \"white\", \"red\", \"green\", \"blue\"]\n\napp = App()\napp.bg = \"black\"\napp.text_color = \"white\"\n\ntitle1 = Text(app, text=\"Background color\")\nbg_combo = Combo(app, options=colors, selected=app.bg, command=update_bg)\n\ntitle2 = Text(app, text=\"Text color\")\ntext_combo = Combo(app, options=colors, selected=app.text_color, command=update_text)\n\napp.display()",
            "title": "Change your apps appearance"
        },
        {
            "location": "/recipes/#scale-an-image",
            "text": "Display an image on the screen with 2 sliders, 1 for height and 1 for width.  from guizero import App, Slider, Picture\n\ndef resize():\n    picture.width = width.value\n    picture.height = height.value\n\napp = App(layout=\"grid\")\n\npicture = Picture(app, image=\"image.gif\", grid=[0,1])\n\nwidth = Slider(app, command=resize, grid=[0,0], start=1, end=picture.width)\nwidth.width = picture.width\nwidth.value = picture.width\n\nheight = Slider(app, command=resize, horizontal=False, grid=[1,1], start=1, end=picture.height)\nheight.height = picture.height\nheight.value = picture.height\n\napp.display()",
            "title": "Scale an image"
        },
        {
            "location": "/app/",
            "text": "App\n\n\n(Contains a \ntkinter.Tk\n object)\n\n\n__init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None, visible=True)\n\n\nWhat is it?\n\n\nThe \nApp\n object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.\n\n\n\n\nHow do I make one?\n\n\nCreate an \nApp\n object like this:\n\n\nfrom guizero import App\napp = App()\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create an \nApp\n object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this: \napp = App(bg=\"red\", height=200)\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the app window and widgets inside it. Takes a \ncolor\n value.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe height of the window in pixels.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\nNo\n\n\nWhether widgets pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n\"guizero\"\n\n\nNo\n\n\nThe title displayed in the bar at the top of the window.\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe width of the window in pixels.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the App should be visible.\n\n\n\n\n\n\nbgcolor\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nReplaced by \nbg\n parameter\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on an \nApp\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables all the widgets in the app so that they cannot be interacted with\n\n\n\n\n\n\ndisplay()\n\n\n-\n\n\n-\n\n\nDisplays the app on the screen. You \nMUST\n call this method at the end of your program to display the app on the screen.\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables all the widgets in the app\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the app window from view.\n\n\n\n\n\n\non_close(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCalls the given function when the user tries to close the window.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the app window if it was previously hidden\n\n\n\n\n\n\nupdate()\n\n\n-\n\n\n-\n\n\nForce the application to update itself, useful if changes aren't reflected in the UI.\n\n\n\n\n\n\nset_title(title)\n\n\ntitle (string)\n\n\n-\n\n\nReplaced by \ntitle\n property\n\n\n\n\n\n\nbgcolor\n\n\nbgcolor (string)\n\n\n-\n\n\nReplaced by \nbg\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the window\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the app is enabled\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the window\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font that widgets should use\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the App (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\nThe title of the window\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text widgets should use\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text widgets should use\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf the app is visible\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the window\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nApp\n object is called \napp\n you would write \napp.title\n.\n\n\nYou can \nset\n the property (for example \napp.title = \"Hello world\"\n) or \nget\n the value of the property to use (for example \nprint(app.title)\n).\n\n\nExamples\n\n\nCreating an App object\n\n\nCreate an \nApp\n object by calling the \nApp()\n constructor. You should give the object a name so you can refer to it later - in this case we have called it \napp\n. It is best to keep the name you give to your \nApp\n object quite short, as you will have to use it to tell other widgets where they should be stored.\n\n\nAt the end of the program you \nMUST\n tell the app object to begin the display loop.\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()\n\n\n\n\nChanging the title\n\n\nYou can change the title of the app object once it has been created like this:\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()\n\n\n\n\nThis will display the app with the updated title:",
            "title": "App"
        },
        {
            "location": "/app/#app",
            "text": "(Contains a  tkinter.Tk  object)  __init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None, visible=True)",
            "title": "App"
        },
        {
            "location": "/app/#what-is-it",
            "text": "The  App  object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.",
            "title": "What is it?"
        },
        {
            "location": "/app/#how-do-i-make-one",
            "text": "Create an  App  object like this:  from guizero import App\napp = App()\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/app/#starting-parameters",
            "text": "When you create an  App  object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this:  app = App(bg=\"red\", height=200)     Parameter  Data type  Default  Compulsory  Description      bg  color  None  No  The background colour of the app window and widgets inside it. Takes a  color  value.    height  int  500  No  The height of the window in pixels.    layout  string  \"auto\"  No  Whether widgets pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    title  string  \"guizero\"  No  The title displayed in the bar at the top of the window.    width  int  500  No  The width of the window in pixels.    visible  boolean  True  No  If the App should be visible.    bgcolor  string  None  No  Replaced by  bg  parameter     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Starting parameters"
        },
        {
            "location": "/app/#methods",
            "text": "You can call the following methods on an  App  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables all the widgets in the app so that they cannot be interacted with    display()  -  -  Displays the app on the screen. You  MUST  call this method at the end of your program to display the app on the screen.    enable()  -  -  Enables all the widgets in the app    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the app window from view.    on_close(command)  command (function name)  -  Calls the given function when the user tries to close the window.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the app window if it was previously hidden    update()  -  -  Force the application to update itself, useful if changes aren't reflected in the UI.    set_title(title)  title (string)  -  Replaced by  title  property    bgcolor  bgcolor (string)  -  Replaced by  bg  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/app/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  color  The background colour of the window    enabled  boolean  True  if the app is enabled    height  int  The height of the window    font  string  The font that widgets should use    layout  string  The layout being used by the App ( \"auto\" ) or ( \"grid\" )    title  string  The title of the window    text_size  int  The size of the text widgets should use    text_color  color  The colour of the text widgets should use    visible  boolean  If the app is visible    width  int  The width of the window     Refer to a property as  <name of widget>.property . For example, if your  App  object is called  app  you would write  app.title .  You can  set  the property (for example  app.title = \"Hello world\" ) or  get  the value of the property to use (for example  print(app.title) ).",
            "title": "Properties"
        },
        {
            "location": "/app/#examples",
            "text": "Creating an App object  Create an  App  object by calling the  App()  constructor. You should give the object a name so you can refer to it later - in this case we have called it  app . It is best to keep the name you give to your  App  object quite short, as you will have to use it to tell other widgets where they should be stored.  At the end of the program you  MUST  tell the app object to begin the display loop.  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()  Changing the title  You can change the title of the app object once it has been created like this:  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()  This will display the app with the updated title:",
            "title": "Examples"
        },
        {
            "location": "/box/",
            "text": "Box\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, layout=\"auto\", grid=None, align=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nBox\n object is an invisible container which can contain other widgets. It is the only object other than \nApp\n which can act as the \nmaster\n for other objects and can have its own layout manager.\n\n\nYou can use the \nBox\n object to group other objects within your GUI.\n\n\nHow do I make one?\n\n\nCreate a \nBox\n object like this:\n\n\nfrom guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nBox\n object you \nmust\n specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nbox = Box(app, layout=\"grid\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ngrid\n\n\nList\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\n-\n\n\nWhether widgets \ninside this box\n pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\nborder\n\n\nint\n\n\nNone\n\n\nNo\n\n\nSets the border thickness. \n0\n or \nFalse\n is no border. \nTrue\n or value > 1 sets a border.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables all the widgets in the box so that they cannot be interacted with\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables all the widgets in the box\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nset_border(thickness, color)\n\n\nthickness (int), color (\ncolor\n)\n\n\n-\n\n\nSets the border thickness and color. Setting thickness to \n0\n will result in no border.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nborder\n\n\nint\n\n\nThe border thickness, setting to \n0\n or \nFalse\n (the default) there is no border.\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the box is enabled\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font that widgets should use\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the Box (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\nThe \nApp\n object to which this box belongs\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text widgets should use\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text widgets should use\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\n\n\nExamples\n\n\nPutting widgets in a Box\n\n\nA \nBox\n object is invisible, but it can contain other widgets. In this example, there are two \nText\n objects. One has \nbox\n as its master, the other has \napp\n as its master.\n\n\nfrom guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()\n\n\n\n\n\n\nGrouping objects within a Box\n\n\nIt is useful to put objects in a box to group them together. For example here we have given the \napp\n a grid layout, then placed some text at [0,0] and the \nBox\n object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.\n\n\nThe \nBox\n object itself has a grid layout and contains six buttons which are positioned on a \nseparate\n grid layout belonging to the box.\n\n\nfrom guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Box"
        },
        {
            "location": "/box/#box",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, layout=\"auto\", grid=None, align=None, visible=True, enabled=None)",
            "title": "Box"
        },
        {
            "location": "/box/#what-is-it",
            "text": "The  Box  object is an invisible container which can contain other widgets. It is the only object other than  App  which can act as the  master  for other objects and can have its own layout manager.  You can use the  Box  object to group other objects within your GUI.",
            "title": "What is it?"
        },
        {
            "location": "/box/#how-do-i-make-one",
            "text": "Create a  Box  object like this:  from guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/box/#starting-parameters",
            "text": "When you create a  Box  object you  must  specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this:  box = Box(app, layout=\"grid\")     Parameter  Data type  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    grid  List  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    layout  string  \"auto\"  -  Whether widgets  inside this box  pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in pixels or to  \"fill\"    height  size  None  No  Set the height of the widget in pixels or to  \"fill\"    border  int  None  No  Sets the border thickness.  0  or  False  is no border.  True  or value > 1 sets a border.",
            "title": "Starting parameters"
        },
        {
            "location": "/box/#methods",
            "text": "You can call the following methods on a  Box  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    disable()  -  -  Disables all the widgets in the box so that they cannot be interacted with    destroy()  -  -  Destroys the widget    enable()  -  -  Enables all the widgets in the box    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    set_border(thickness, color)  thickness (int), color ( color )  -  Sets the border thickness and color. Setting thickness to  0  will result in no border.    show()  -  -  Displays the widget if it was previously hidden",
            "title": "Methods"
        },
        {
            "location": "/box/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    border  int  The border thickness, setting to  0  or  False  (the default) there is no border.    bg  color  The background colour of the widget    enabled  boolean  True  if the box is enabled    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    font  string  The font that widgets should use    height  size  Set the height of the widget in pixels or to  \"fill\"    layout  string  The layout being used by the Box ( \"auto\" ) or ( \"grid\" )    master  App  The  App  object to which this box belongs    text_size  int  The size of the text widgets should use    text_color  color  The colour of the text widgets should use    visible  boolean  If this widget is visible    width  size  Set the width of the widget in pixels or to  \"fill\"",
            "title": "Properties"
        },
        {
            "location": "/box/#examples",
            "text": "Putting widgets in a Box  A  Box  object is invisible, but it can contain other widgets. In this example, there are two  Text  objects. One has  box  as its master, the other has  app  as its master.  from guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()   Grouping objects within a Box  It is useful to put objects in a box to group them together. For example here we have given the  app  a grid layout, then placed some text at [0,0] and the  Box  object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.  The  Box  object itself has a grid layout and contains six buttons which are positioned on a  separate  grid layout belonging to the box.  from guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/buttongroup/",
            "text": "ButtonGroup\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, options=[], selected=None, horizontal=False, command=None, grid=None, align=None, args=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nButtonGroup\n object displays a group of radio buttons, allowing the user to choose a single option.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nButtonGroup\n object like this:\n\n\nfrom guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=\"cheese\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nButtonGroup\n object you \nmust\n specify a \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\noptions\n\n\nlist or 2D List\n\n\n-\n\n\nNo\n\n\nEither a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option.\n\n\n\n\n\n\nselected\n\n\nstring\n\n\n-\n\n\n-\n\n\nThe option that should be selected, if a value isn't provided the first option will be selected.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the selected option changes.\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nlist [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the buttons stack vertically or horizontally. (Defaults to vertical)\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on an \nButtonGroup\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nappend(option)\n\n\nitem (string)\n\n\n-\n\n\nAppends a new \noption\n to the end of the ButtonGroup.\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nget_group_as_list()\n\n\n-\n\n\nlist\n\n\nReturns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\ninsert(index, option)\n\n\nindex (int), option (string)\n\n\n-\n\n\nInsert a new \noption\n in the ButtonGroup at \nindex\n\n\n\n\n\n\nremove(option)\n\n\nitem (string)\n\n\nBoolean\n\n\nRemoves the first \noption\n from the ButtonGroup. Returns \nTrue\n if an item was removed.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the selected option changes\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(value)\n\n\nvalue (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe hidden value associated with the currently selected option\n\n\n\n\n\n\nvalue_text\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nButtonGroup\n object is called \nchoice\n you would write \nchoice.value\n.\n\n\nYou can \nset\n the property (for example \nchoice.value = \"2\"\n) or \nget\n the value of the property to use (for example \nprint(choice.value)\n).\n\n\nExamples\n\n\nCreating a ButtonGroup with a 2D list\n\n\nIf you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:\n\n\nfrom guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#buttongroup",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, options=[], selected=None, horizontal=False, command=None, grid=None, align=None, args=None, visible=True, enabled=None)",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#what-is-it",
            "text": "The  ButtonGroup  object displays a group of radio buttons, allowing the user to choose a single option.",
            "title": "What is it?"
        },
        {
            "location": "/buttongroup/#how-do-i-make-one",
            "text": "Create a  ButtonGroup  object like this:  from guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=\"cheese\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/buttongroup/#starting-parameters",
            "text": "When you create a  ButtonGroup  object you  must  specify a  master  and you can specify any of the optional parameters. Specify parameters in the brackets like this:  choice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    options  list or 2D List  -  No  Either a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option.    selected  string  -  -  The option that should be selected, if a value isn't provided the first option will be selected.    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    command  function name  None  -  The name of a function to call when the selected option changes.    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  list [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  boolean  False  -  Whether the buttons stack vertically or horizontally. (Defaults to vertical)    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in characters or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/buttongroup/#methods",
            "text": "You can call the following methods on an  ButtonGroup  object.     Method  Takes  Returns  Description      append(option)  item (string)  -  Appends a new  option  to the end of the ButtonGroup.    after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    get_group_as_list()  -  list  Returns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    insert(index, option)  index (int), option (string)  -  Insert a new  option  in the ButtonGroup at  index    remove(option)  item (string)  Boolean  Removes the first  option  from the ButtonGroup. Returns  True  if an item was removed.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the selected option changes    get()  -  string  Replaced by  value  property    set(value)  value (string)  -  Replaced by  value  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/buttongroup/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\"    master  App or Box  The container to which this widget belongs    value  string  The hidden value associated with the currently selected option    value_text  string  The text associated with the currently selected option    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  ButtonGroup  object is called  choice  you would write  choice.value .  You can  set  the property (for example  choice.value = \"2\" ) or  get  the value of the property to use (for example  print(choice.value) ).",
            "title": "Properties"
        },
        {
            "location": "/buttongroup/#examples",
            "text": "Creating a ButtonGroup with a 2D list  If you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:  from guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/checkbox/",
            "text": "CheckBox\n\n\n(Contains a \ntkinter.Checkbutton\n object)\n\n\n__init__(self, master, text, command=None, grid=None, align=None, args=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nCheckBox\n object displays a check box to allow an option to be ticked or unticked\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCheckBox\n object like this:\n\n\nfrom guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCheckBox\n object you \nmust\n specify \nmaster\n and \ntext\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncheckbox = CheckBox(app, text=\"Add extra glitter\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\nNo\n\n\nThe text to display next to the check box\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when this checkbox is ticked/unticked\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCheckBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nSwitches the \nCheckBox\n to the opposite of its current value. i.e. if it is ticked, untick it and vice versa\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the checkbox is ticked/unticked\n\n\n\n\n\n\nchange_text(newtext)\n\n\nnewtext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_text()\n\n\n-\n\n\nstring\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_value()\n\n\n-\n\n\nint\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text associated with the checkbox\n\n\n\n\n\n\nvalue\n\n\nint\n\n\n1\n if the CheckBox is ticked or \n0\n if it is not ticked\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCheckBox\n object is called \ncheckbox\n you would write \ncheckbox.value\n.\n\n\nYou can \nset\n the property (for example \ncheckbox.value = 1\n) or \nget\n the value of the property to use (for example \nprint(checkbox.value)\n).\n\n\nExamples\n\n\nCreating multiple CheckBoxes\n\n\nCreate multiple CheckBoxes like this.\n\n\nfrom guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()\n\n\n\n\nCalling a function when a CheckBox value changes\n\n\nYou can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.\n\n\nfrom guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#checkbox",
            "text": "(Contains a  tkinter.Checkbutton  object)  __init__(self, master, text, command=None, grid=None, align=None, args=None, visible=True, enabled=None)",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#what-is-it",
            "text": "The  CheckBox  object displays a check box to allow an option to be ticked or unticked",
            "title": "What is it?"
        },
        {
            "location": "/checkbox/#how-do-i-make-one",
            "text": "Create a  CheckBox  object like this:  from guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/checkbox/#starting-parameters",
            "text": "When you create a  CheckBox  object you  must  specify  master  and  text  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  checkbox = CheckBox(app, text=\"Add extra glitter\")     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    text  string  \"\"  No  The text to display next to the check box    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    command  function name  None  -  The name of a function to call when this checkbox is ticked/unticked    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in characters or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/checkbox/#methods",
            "text": "You can call the following methods on a  CheckBox  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Switches the  CheckBox  to the opposite of its current value. i.e. if it is ticked, untick it and vice versa    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the checkbox is ticked/unticked    change_text(newtext)  newtext (string)  -  Replaced by the  text  property    get_text()  -  string  Replaced by the  text  property    get_value()  -  int  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/checkbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\"    master  App or Box  The container to which this widget belongs    text  string  The text associated with the checkbox    value  int  1  if the CheckBox is ticked or  0  if it is not ticked    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  CheckBox  object is called  checkbox  you would write  checkbox.value .  You can  set  the property (for example  checkbox.value = 1 ) or  get  the value of the property to use (for example  print(checkbox.value) ).",
            "title": "Properties"
        },
        {
            "location": "/checkbox/#examples",
            "text": "Creating multiple CheckBoxes  Create multiple CheckBoxes like this.  from guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()  Calling a function when a CheckBox value changes  You can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.  from guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/combo/",
            "text": "Combo\n\n\n(Contains a \ntkinter.OptionMenu\n object)\n\n\n__init__(self, master, options=[], selected=None, command=None, grid=None, align=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nCombo\n object displays a drop down box allowing a single option to be selected from a list of options.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCombo\n object like this:\n\n\nfrom guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCombo\n object you \nmust\n specify a \nmaster\n  and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\noptions\n\n\nList\n\n\n[]\n\n\nNo\n\n\nA list of options to display\n\n\n\n\n\n\nselected\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nThe option to select by default\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the Combo will be given.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCombo\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nappend(option)\n\n\nitem (string)\n\n\n-\n\n\nAppends a new \noption\n to the end of the Combo.\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nRemoves all options from the Combo box\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\ninsert(index, option)\n\n\nindex (int), item (string)\n\n\n-\n\n\nInsert a new \noption\n in the Combo at \nindex\n\n\n\n\n\n\nremove(option)\n\n\nitem (string)\n\n\nBoolean\n\n\nRemoves the first \noption\n from the Combo. Returns \nTrue\n if an item was removed.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nselect_default()\n\n\n-\n\n\n-\n\n\nResets the combo box so that the first item is selected\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when a different option is selected.\n\n\n\n\n\n\nadd_option(option)\n\n\noption (string)\n\n\n-\n\n\nAdds a new item to the combo box with the value \noption\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCombo\n object is called \ncombo\n you would write \ncombo.value\n.\n\n\nYou can \nset\n the property (for example \ncombo.value = \"Chicken\"\n) or \nget\n the value of the property to use (for example \nprint(combo.value)\n).\n\n\nExamples\n\n\nCalling a function when the value selected changes\n\n\nYou can call a function when the selected value in a \nCombo\n object changes. The function you call can take either zero or one argument, if the function takes one argument it will automatically be passed a string containing the currently selected value from the \nCombo\n object.\n\n\nfrom guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Combo"
        },
        {
            "location": "/combo/#combo",
            "text": "(Contains a  tkinter.OptionMenu  object)  __init__(self, master, options=[], selected=None, command=None, grid=None, align=None, visible=True, enabled=None)",
            "title": "Combo"
        },
        {
            "location": "/combo/#what-is-it",
            "text": "The  Combo  object displays a drop down box allowing a single option to be selected from a list of options.",
            "title": "What is it?"
        },
        {
            "location": "/combo/#how-do-i-make-one",
            "text": "Create a  Combo  object like this:  from guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/combo/#starting-parameters",
            "text": "When you create a  Combo  object you  must  specify a  master   and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  combo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    options  List  []  No  A list of options to display    selected  string  None  No  The option to select by default    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    command  function name  None  -  The name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the Combo will be given.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in characters or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/combo/#methods",
            "text": "You can call the following methods on a  Combo  object.     Method  Takes  Returns  Description      append(option)  item (string)  -  Appends a new  option  to the end of the Combo.    after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Removes all options from the Combo box    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    insert(index, option)  index (int), item (string)  -  Insert a new  option  in the Combo at  index    remove(option)  item (string)  Boolean  Removes the first  option  from the Combo. Returns  True  if an item was removed.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    select_default()  -  -  Resets the combo box so that the first item is selected    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when a different option is selected.    add_option(option)  option (string)  -  Adds a new item to the combo box with the value  option    get()  -  string  Replaced by the  value  property    set(text)  text (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/combo/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\"    master  App or Box  The container to which this widget belongs    value  string  The text associated with the currently selected option    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  Combo  object is called  combo  you would write  combo.value .  You can  set  the property (for example  combo.value = \"Chicken\" ) or  get  the value of the property to use (for example  print(combo.value) ).",
            "title": "Properties"
        },
        {
            "location": "/combo/#examples",
            "text": "Calling a function when the value selected changes  You can call a function when the selected value in a  Combo  object changes. The function you call can take either zero or one argument, if the function takes one argument it will automatically be passed a string containing the currently selected value from the  Combo  object.  from guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/listbox/",
            "text": "ListBox\n\n\n(Contains a \ntkinter.Listbox\n object)\n\n\n__init__(self, master, items=None, selected=None, command=None, grid=None, align=None, visible=True, enabled=None, multiselect=False, scrollbar=False)\n\n\nWhat is it?\n\n\nThe \nListBox\n object displays a list of items from which either single or multiple items can be selected.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nListBox\n object like this:\n\n\nfrom guizero import App, ListBox\napp = App()\nlistbox = ListBox(app, items=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nListBox\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nlistbox = ListBox(app, items=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\n\n\nIf you want the \nListBox\n to allow multiple items to be selected you must set the \nmultiselect\n optional parameter to \nTrue\n: \nlistbox = ListBox(app, multiselect=True)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nselected\n\n\nstring or List\n\n\nNone\n\n\nNo\n\n\nThe item or items to select by default\n\n\n\n\n\n\nitems\n\n\nList\n\n\n-\n\n\nYes\n\n\nA list of items to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the ListBox will be given.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nmultiselect\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nIf the widget should allow multiple items to be selected.\n\n\n\n\n\n\nscrollbar\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nIf the widget should have a verticle scrollbar.\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nListBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(item)\n\n\nitem (string)\n\n\n-\n\n\nAppends a new \nitem\n to the end of the ListBox.\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears all the items in a ListBox\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\ninsert(index, item)\n\n\nindex (int), item (string)\n\n\n-\n\n\nInsert a new \nitem\n in the ListBox at \nindex\n\n\n\n\n\n\nremove(item)\n\n\nitem (string)\n\n\nBoolean\n\n\nRemoves the first \nitem\n from the ListBox. Returns \nTrue\n if an item was removed.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when a different option is selected.\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nitems\n\n\nList\n\n\nReturns a list of items in the ListBox\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nSets or returns the items selected in a ListBox. Returns \nNone\n if 0 items are selected. If the ListBox is a not \nmultiselect\n, \nvalue\n is the item selected, if the ListBox is a \nmultiselect\n, \nvalue\n is a list of items selected.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nListBox\n object is called \nlistbox\n you would write \nlistbox.value\n.\n\n\nYou can \nset\n the property (for example \nlistbox.value = \"Chicken\"\n) or \nget\n the value of the property to use (for example \nprint(listbox.value)\n).\n\n\nExamples\n\n\n Select a text color from a ListBox \n\n\nWhen an item in the ListBox is selected a function will be called to change the color of the text.\n\n\nfrom guizero import App, ListBox, Text\n\ndef change_color(value):\n    t.text_color = value\n\na = App()\n\nt = Text(a, text=\"Its a ListBox\", color=\"black\")\n\nlistbox = ListBox(\n    a, \n    items=[\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"turquoise\", \"pink\", \"orange\", \"black\", \"brown\", \"cyan\"], \n    selected=\"black\", \n    command=change_color,\n    scrollbar=True)\n\na.display()",
            "title": "ListBox"
        },
        {
            "location": "/listbox/#listbox",
            "text": "(Contains a  tkinter.Listbox  object)  __init__(self, master, items=None, selected=None, command=None, grid=None, align=None, visible=True, enabled=None, multiselect=False, scrollbar=False)",
            "title": "ListBox"
        },
        {
            "location": "/listbox/#what-is-it",
            "text": "The  ListBox  object displays a list of items from which either single or multiple items can be selected.",
            "title": "What is it?"
        },
        {
            "location": "/listbox/#how-do-i-make-one",
            "text": "Create a  ListBox  object like this:  from guizero import App, ListBox\napp = App()\nlistbox = ListBox(app, items=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/listbox/#starting-parameters",
            "text": "When you create a  ListBox  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  listbox = ListBox(app, items=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])  If you want the  ListBox  to allow multiple items to be selected you must set the  multiselect  optional parameter to  True :  listbox = ListBox(app, multiselect=True)     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    selected  string or List  None  No  The item or items to select by default    items  List  -  Yes  A list of items to display    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    command  function name  None  -  The name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the ListBox will be given.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    multiselect  boolean  False  No  If the widget should allow multiple items to be selected.    scrollbar  boolean  False  No  If the widget should have a verticle scrollbar.    width  size  None  No  Set the width of the widget in characters or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/listbox/#methods",
            "text": "You can call the following methods on a  ListBox  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(item)  item (string)  -  Appends a new  item  to the end of the ListBox.    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears all the items in a ListBox    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    insert(index, item)  index (int), item (string)  -  Insert a new  item  in the ListBox at  index    remove(item)  item (string)  Boolean  Removes the first  item  from the ListBox. Returns  True  if an item was removed.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when a different option is selected.",
            "title": "Methods"
        },
        {
            "location": "/listbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\"    items  List  Returns a list of items in the ListBox    master  App or Box  The container to which this widget belongs    value  string  Sets or returns the items selected in a ListBox. Returns  None  if 0 items are selected. If the ListBox is a not  multiselect ,  value  is the item selected, if the ListBox is a  multiselect ,  value  is a list of items selected.    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  ListBox  object is called  listbox  you would write  listbox.value .  You can  set  the property (for example  listbox.value = \"Chicken\" ) or  get  the value of the property to use (for example  print(listbox.value) ).",
            "title": "Properties"
        },
        {
            "location": "/listbox/#examples",
            "text": "Select a text color from a ListBox   When an item in the ListBox is selected a function will be called to change the color of the text.  from guizero import App, ListBox, Text\n\ndef change_color(value):\n    t.text_color = value\n\na = App()\n\nt = Text(a, text=\"Its a ListBox\", color=\"black\")\n\nlistbox = ListBox(\n    a, \n    items=[\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"turquoise\", \"pink\", \"orange\", \"black\", \"brown\", \"cyan\"], \n    selected=\"black\", \n    command=change_color,\n    scrollbar=True)\n\na.display()",
            "title": "Examples"
        },
        {
            "location": "/menubar/",
            "text": "MenuBar\n\n\n(Contains a \ntkinter.Menu\n object)\n\n\n__init__(self, master, toplevel, options)\n\n\nWhat is it?\n\n\nThe \nMenuBar\n object displays a menu at the top of the screen, with each menu option leading to a submenu.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nMenuBar\n object like this:\n\n\nfrom guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nMenuBar\n object you \nmust\n specify all of the parameters.\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntoplevel\n\n\nlist\n\n\n-\n\n\nYes\n\n\nA list of top level menu items\n\n\n\n\n\n\noptions\n\n\n3D list\n\n\n-\n\n\nYes\n\n\nA list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.\n\n\n\n\n\n\n\n\nThe \ntoplevel\n parameter should be a list of options you wish to display on the menu. In the example, the \ntoplevel\n options are File and Edit:\n\n\n\n\nThe options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the \ntoplevel\n list, so the first list of submenu items provided in \noptions\n will be the submenu for the first menu heading provided in \ntoplevel\n and so on.\n\n\nThe menu item sub-sublists within \noptions\n should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function \nfile_function\n is called if this option is clicked on.\n\n\n[\"File option 1\", file_function]\n\n\n\n\nThe MenuBar is never displayed on a grid so there are no grid or alignment parameters.\n\n\nMethods\n\n\nYou can call the following methods on an \nMenuBar\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\nThe \nApp\n object to which this MenuBar belongs",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#menubar",
            "text": "(Contains a  tkinter.Menu  object)  __init__(self, master, toplevel, options)",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#what-is-it",
            "text": "The  MenuBar  object displays a menu at the top of the screen, with each menu option leading to a submenu.",
            "title": "What is it?"
        },
        {
            "location": "/menubar/#how-do-i-make-one",
            "text": "Create a  MenuBar  object like this:  from guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/menubar/#starting-parameters",
            "text": "When you create a  MenuBar  object you  must  specify all of the parameters.     Parameter  Takes  Default  Compulsory  Description      master  App  -  Yes  The container to which this widget belongs    toplevel  list  -  Yes  A list of top level menu items    options  3D list  -  Yes  A list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.     The  toplevel  parameter should be a list of options you wish to display on the menu. In the example, the  toplevel  options are File and Edit:   The options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the  toplevel  list, so the first list of submenu items provided in  options  will be the submenu for the first menu heading provided in  toplevel  and so on.  The menu item sub-sublists within  options  should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function  file_function  is called if this option is clicked on.  [\"File option 1\", file_function]  The MenuBar is never displayed on a grid so there are no grid or alignment parameters.",
            "title": "Starting parameters"
        },
        {
            "location": "/menubar/#methods",
            "text": "You can call the following methods on an  MenuBar  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.",
            "title": "Methods"
        },
        {
            "location": "/menubar/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      master  App  The  App  object to which this MenuBar belongs",
            "title": "Properties"
        },
        {
            "location": "/picture/",
            "text": "Picture\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, image=None, grid=None, align=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nPicture\n object displays an image.\n\n\n\n\nWindows & Linux support GIF and PNG file types, MacOS only supports GIF.\n\n\nHow do I make one?\n\n\nCreate a \nPicture\n object like this:\n\n\nfrom guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()\n\n\n\n\nYou must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called \nimages\n you would write:\n\n\npicture = Picture(app, image=\"images/test.gif\")\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPicture\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \npicture = Picture(app, image=\"test.gif\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nNone\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in pixels\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in pixels\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPicture\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nset(image)\n\n\nimage (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in pixels\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in pixels\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPicture\n object is called \npicture\n you would write \npicture.value\n.\n\n\nYou can \nset\n the property (for example \npicture.value = \"star.gif\"\n) or \nget\n the value of the property to use (for example \nprint(picture.value)\n).\n\n\nImage types\n\n\nFind out \nwhich file types are supported\n (dependent on platform and whether PIL is available).",
            "title": "Picture"
        },
        {
            "location": "/picture/#picture",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, image=None, grid=None, align=None, visible=True, enabled=None)",
            "title": "Picture"
        },
        {
            "location": "/picture/#what-is-it",
            "text": "The  Picture  object displays an image.   Windows & Linux support GIF and PNG file types, MacOS only supports GIF.",
            "title": "What is it?"
        },
        {
            "location": "/picture/#how-do-i-make-one",
            "text": "Create a  Picture  object like this:  from guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()  You must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called  images  you would write:  picture = Picture(app, image=\"images/test.gif\")",
            "title": "How do I make one?"
        },
        {
            "location": "/picture/#starting-parameters",
            "text": "When you create a  Picture  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  picture = Picture(app, image=\"test.gif\")     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    image  string  None  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in pixels    height  size  None  No  Set the height of the widget in pixels",
            "title": "Starting parameters"
        },
        {
            "location": "/picture/#methods",
            "text": "You can call the following methods on a  Picture  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    set(image)  image (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/picture/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in pixels    image  string  The file path, tkinter.PhotoImage or PIL.Image you wish to display    master  App or Box  The container to which this widget belongs    value  string  The file path, tkinter.PhotoImage or PIL.Image you wish to display    visible  boolean  If this widget is visible    width  size  Set the width of the widget in pixels     Refer to a property as  <name of widget>.property . For example, if your  Picture  object is called  picture  you would write  picture.value .  You can  set  the property (for example  picture.value = \"star.gif\" ) or  get  the value of the property to use (for example  print(picture.value) ).",
            "title": "Properties"
        },
        {
            "location": "/picture/#image-types",
            "text": "Find out  which file types are supported  (dependent on platform and whether PIL is available).",
            "title": "Image types"
        },
        {
            "location": "/pushbutton/",
            "text": "PushButton\n\n\n(Contains a \ntkinter.Button\n object)\n\n\n__init__(self, master, command=None, args=None, text=\"Button\", image=None, pady=10, padx=10, grid=None, align=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nPushButton\n object displays a button with text or an image, which calls a function when pressed.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nPushButton\n object like this:\n\n\nfrom guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPushButton\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nbutton = PushButton(app)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the button is pressed.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nNone\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display. If both an image and text are specified, the image will override the text.\n\n\n\n\n\n\npadx\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much horizontal padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\npady\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much vertical padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"Button\"\n\n\n-\n\n\nThe text to display on the button\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or pixels if its an image button or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or pixels if its an image button or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPushButton\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nimage(image_source)\n\n\nimage_source (string)\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display.\n\n\n\n\n\n\npadding(padx, pady)\n\n\npadx (int), pady(int)\n\n\n-\n\n\nSets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nChanges the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the button is pressed .\n\n\n\n\n\n\nchange_command(newcommand, args)\n\n\nnewcommand (function name), args (list)\n\n\n-\n\n\nReplaced by update_command function\n\n\n\n\n\n\nicon(icon)\n\n\nicon (string)\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nset_text(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\ntoggle_state()\n\n\n-\n\n\n-\n\n\nRenamed to \ntoggle()\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text on the button\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or pixels if its an image button or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text on the button\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text on the button\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text on the button\n\n\n\n\n\n\nvalue\n\n\nint\n\n\nReturns 1 when the button is pressed, 0 if the button is released\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or pixels if its an image button or to \n\"fill\"\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPushButton\n object is called \nbutton\n you would write \nbutton.value\n.\n\n\nYou can \nset\n the property (for example \nbutton.bg = \"red\"\n) or \nget\n the value of the property to use (for example \nprint(button.bg)\n).",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#pushbutton",
            "text": "(Contains a  tkinter.Button  object)  __init__(self, master, command=None, args=None, text=\"Button\", image=None, pady=10, padx=10, grid=None, align=None, visible=True, enabled=None)",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#what-is-it",
            "text": "The  PushButton  object displays a button with text or an image, which calls a function when pressed.",
            "title": "What is it?"
        },
        {
            "location": "/pushbutton/#how-do-i-make-one",
            "text": "Create a  PushButton  object like this:  from guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/pushbutton/#starting-parameters",
            "text": "When you create a  PushButton  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  button = PushButton(app)     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    command  function name  None  -  The name of a function to call when the button is pressed.    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    image  string  None  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display. If both an image and text are specified, the image will override the text.    padx  int  10  -  How much horizontal padding to add between the text/icon and the edge of the button.    pady  int  10  -  How much vertical padding to add between the text/icon and the edge of the button.    text  string  \"Button\"  -  The text to display on the button    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in characters or pixels if its an image button or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or pixels if its an image button or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/pushbutton/#methods",
            "text": "You can call the following methods on a  PushButton  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    image(image_source)  image_source (string)  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display.    padding(padx, pady)  padx (int), pady(int)  -  Sets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Changes the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the button is pressed .    change_command(newcommand, args)  newcommand (function name), args (list)  -  Replaced by update_command function    icon(icon)  icon (string)  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display    set_text(text)  text (string)  -  Replaced by the  text  property    toggle_state()  -  -  Renamed to  toggle()     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/pushbutton/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text on the button    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or pixels if its an image button or to  \"fill\"    master  App or Box  The container to which this widget belongs    text  string  The text on the button    text_color  color  The colour of the text on the button    text_size  int  The size of the text on the button    value  int  Returns 1 when the button is pressed, 0 if the button is released    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or pixels if its an image button or to  \"fill\"     Refer to a property as  <name of widget>.property . For example, if your  PushButton  object is called  button  you would write  button.value .  You can  set  the property (for example  button.bg = \"red\" ) or  get  the value of the property to use (for example  print(button.bg) ).",
            "title": "Properties"
        },
        {
            "location": "/slider/",
            "text": "Slider\n\n\n(Contains a \ntkinter.Scale\n object)\n\n\n__init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nSlider\n object displays a bar and selector which can be used to specify a value in a range.\n\n\nThe above code looks like this on Windows:\n\n\n\nHow do I make one?\n\n\nCreate a \nSlider\n object like this:\n\n\nfrom guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()\n\n\n\n\nStarting paramters\n\n\nWhen you create a \nSlider\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \nslider = Slider(app, horizontal=False)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the slider value is changed\n\n\n\n\n\n\nend\n\n\nint\n\n\n100\n\n\n-\n\n\nThe largest value selectable on the slider\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nBoolean\n\n\nTrue\n\n\n-\n\n\nWhether you wish to display your slider horizontally or vertically (defaults to horizontal)\n\n\n\n\n\n\nstart\n\n\nint\n\n\n0\n\n\n-\n\n\nThe smallest value selectable on the slider\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nSlider\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nthe function specified in \ncommand\n\n\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the slider value is changed\n\n\n\n\n\n\nadd_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nSets the function called when the slider value is changed to\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe current value of the slider\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in pixels or to \n\"fill\"\n\n\n\n\n\n\n\n\nExamples\n\n\nCalling a function when the slider value changes\n\n\nYou can specify a function to call when the slider value changes. Your function \nMUST\n have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called \nslider_value\n in the example) when it is called.\n\n\nThis code has a slider and a text box, and the text box updates automatically to display the current value of the slider.\n\n\n\n\nfrom guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Slider"
        },
        {
            "location": "/slider/#slider",
            "text": "(Contains a  tkinter.Scale  object)  __init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)",
            "title": "Slider"
        },
        {
            "location": "/slider/#what-is-it",
            "text": "The  Slider  object displays a bar and selector which can be used to specify a value in a range.  The above code looks like this on Windows:",
            "title": "What is it?"
        },
        {
            "location": "/slider/#how-do-i-make-one",
            "text": "Create a  Slider  object like this:  from guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/slider/#starting-paramters",
            "text": "When you create a  Slider  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  slider = Slider(app, horizontal=False)     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    command  function name  None  -  The name of a function to call when the slider value is changed    end  int  100  -  The largest value selectable on the slider    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  Boolean  True  -  Whether you wish to display your slider horizontally or vertically (defaults to horizontal)    start  int  0  -  The smallest value selectable on the slider    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in pixels or to  \"fill\"    height  size  None  No  Set the height of the widget in pixels or to  \"fill\"",
            "title": "Starting paramters"
        },
        {
            "location": "/slider/#methods",
            "text": "You can call the following methods on a  Slider  object.     Method  Takes  Returns  Description      the function specified in  command       after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when the slider value is changed    add_command(command)  command (function name)  -  Sets the function called when the slider value is changed to     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/slider/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in pixels or to  \"fill\"    master  App or Box  The container to which this widget belongs    text_size  int  The size of the text    text_color  color  The colour of the text    value  string  The current value of the slider    visible  boolean  If this widget is visible    width  size  Set the width of the widget in pixels or to  \"fill\"",
            "title": "Properties"
        },
        {
            "location": "/slider/#examples",
            "text": "Calling a function when the slider value changes  You can specify a function to call when the slider value changes. Your function  MUST  have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called  slider_value  in the example) when it is called.  This code has a slider and a text box, and the text box updates automatically to display the current value of the slider.   from guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/text/",
            "text": "Text\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, text=\"\", size=12, color=\"black\", bg=None, font=\"Helvetica\", grid=None, align=None, visible=True, enabled=None)\n\n\nWhat is it?\n\n\nThe \nText\n object displays non editable text in your app, useful for titles, labels and instructions.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nText\n object like this:\n\n\nfrom guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nText\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \ntext = Text(app, text=\"hi\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nblack\n\n\n-\n\n\nThe colour of the text. Accepts some colour strings (e.g. \nred\n) and colours specified in hex format (e.g. \n#0099ff\n)\n\n\n\n\n\n\nfont\n\n\nstring\n\n\n\"Helvetica\"\n\n\n-\n\n\nThe font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\n12\n\n\n-\n\n\nThe font size of the text\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nThe text you want to display\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nNone\n\n\nNo\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nText\n object..\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the object\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the text\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ncolor(color)\n\n\ncolor (string)\n\n\n-\n\n\nReplaced by \ntext_color\n property\n\n\n\n\n\n\nfont_face(font)\n\n\nfont (string)\n\n\n-\n\n\nReplaced by \nfont\n property\n\n\n\n\n\n\nfont_size(size)\n\n\nsize (int)\n\n\n-\n\n\nReplaced by \nsize\n property\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"",
            "title": "Text"
        },
        {
            "location": "/text/#text",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, text=\"\", size=12, color=\"black\", bg=None, font=\"Helvetica\", grid=None, align=None, visible=True, enabled=None)",
            "title": "Text"
        },
        {
            "location": "/text/#what-is-it",
            "text": "The  Text  object displays non editable text in your app, useful for titles, labels and instructions.",
            "title": "What is it?"
        },
        {
            "location": "/text/#how-do-i-make-one",
            "text": "Create a  Text  object like this:  from guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/text/#starting-parameters",
            "text": "When you create a  Text  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  text = Text(app, text=\"hi\")     Parameter  Data type  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    color  color  black  -  The colour of the text. Accepts some colour strings (e.g.  red ) and colours specified in hex format (e.g.  #0099ff )    font  string  \"Helvetica\"  -  The font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    text_size  int  12  -  The font size of the text    text  string  \"\"  -  The text you want to display    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    width  size  None  No  Set the width of the widget in characters or to  \"fill\"    height  size  None  No  Set the height of the widget in characters or to  \"fill\"",
            "title": "Starting parameters"
        },
        {
            "location": "/text/#methods",
            "text": "You can call the following methods on a  Text  object..     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the object    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the text    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    color(color)  color (string)  -  Replaced by  text_color  property    font_face(font)  font (string)  -  Replaced by  font  property    font_size(size)  size (int)  -  Replaced by  size  property    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/text/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\"    master  App or Box  The container to which this widget belongs    text_size  int  The size of the text    text_color  color  The colour of the text    value  string  The text    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"",
            "title": "Properties"
        },
        {
            "location": "/textbox/",
            "text": "TextBox\n\n\n(Contains a \ntkinter.Entry\n object)\n\n\n__init__(self, master, text=\"\", width=10, height=1, grid=None, align=None, visible=True, enabled=None, multiline=False, scrollbar=False, command=None)\n\n\nWhat is it\n\n\nThe \nTextBox\n object displays a text box which the user can type in.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nTextBox\n object like this:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nTextBox\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ntextbox = TextBox(app, text=\"Please enter some text\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nAny text you wish to be pre-filled in the text box\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n10\n\n\n-\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\nheight\n\n\nint\n\n\n1\n\n\n-\n\n\nSet the height of the widget in characters or to \n\"fill\"\n, only effective if \nmultiline\n is \nTrue\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nmultiline\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nCreate a multi-line text box.\n\n\n\n\n\n\nscrollbar\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nAdd a vertical scrollbar to a multi-line text box\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the text is changed. This function MUST take either zero or one argument, if the function takes one argument the key which was added to the textbox will be returned.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on your TextBox object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the text box\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the textbox\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nresize(width, height)\n\n\nwidth (int), height (int)\n\n\n-\n\n\nSets the width and height of the widget\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the text is changed.\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height of the widget in characters or to \n\"fill\"\n, only effective if \nmultiline\n is \nTrue\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text in the TextBox\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width of the widget in characters or to \n\"fill\"\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nExamples\n\n\nCreating a TextBox with default text\n\n\nYou can set the default text in a TextBox when it is created using the \ntext\n parameter:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()\n\n\n\n\nCreating a multi-line TextBox\n\n\nYou can create a text box which is capable of capturing multiple lines of text by setting the \nmultiline\n parameter to \nTrue\n and giving the textbox a \nheight\n:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True)\napp.display()\n\n\n\n\nMulti-line text boxes can also be given a scrollbar by setting the \nscrollbar\n parameter to \nTrue\n:\n\n\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True, scrollbar=True)",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#textbox",
            "text": "(Contains a  tkinter.Entry  object)  __init__(self, master, text=\"\", width=10, height=1, grid=None, align=None, visible=True, enabled=None, multiline=False, scrollbar=False, command=None)",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#what-is-it",
            "text": "The  TextBox  object displays a text box which the user can type in.",
            "title": "What is it"
        },
        {
            "location": "/textbox/#how-do-i-make-one",
            "text": "Create a  TextBox  object like this:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/textbox/#starting-parameters",
            "text": "When you create a  TextBox  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  textbox = TextBox(app, text=\"Please enter some text\")     Parameter  Data type  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    text  string  \"\"  -  Any text you wish to be pre-filled in the text box    width  int  10  -  Set the width of the widget in characters or to  \"fill\"    height  int  1  -  Set the height of the widget in characters or to  \"fill\" , only effective if  multiline  is  True    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    multiline  boolean  False  No  Create a multi-line text box.    scrollbar  boolean  False  No  Add a vertical scrollbar to a multi-line text box    command  function name  None  -  The name of a function to call when the text is changed. This function MUST take either zero or one argument, if the function takes one argument the key which was added to the textbox will be returned.",
            "title": "Starting parameters"
        },
        {
            "location": "/textbox/#methods",
            "text": "You can call the following methods on your TextBox object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the text box    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the textbox    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    resize(width, height)  width (int), height (int)  -  Sets the width and height of the widget    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when the text is changed.    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/textbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height of the widget in characters or to  \"fill\" , only effective if  multiline  is  True    master  App or Box  The container to which this widget belongs    value  string  The text in the TextBox    visible  boolean  If this widget is visible    width  size  Set the width of the widget in characters or to  \"fill\"    text_size  int  The size of the text    text_color  color  The colour of the text",
            "title": "Properties"
        },
        {
            "location": "/textbox/#examples",
            "text": "Creating a TextBox with default text  You can set the default text in a TextBox when it is created using the  text  parameter:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()  Creating a multi-line TextBox  You can create a text box which is capable of capturing multiple lines of text by setting the  multiline  parameter to  True  and giving the textbox a  height :  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True)\napp.display()  Multi-line text boxes can also be given a scrollbar by setting the  scrollbar  parameter to  True :  input_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True, scrollbar=True)",
            "title": "Examples"
        },
        {
            "location": "/waffle/",
            "text": "Waffle\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None, visible=True, enabled=None, bg=None)\n\n\nWhat is it\n\n\nThe \nWaffle\n object display an n*n grid of squares with custom dimensions and padding\n\n\n\n\nHow do I make one?\n\n\nCreate a \nWaffle\n object like this:\n\n\nfrom guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nWaffle\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nwaffle = Waffle(app, height=25)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp, Window or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its container. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n.\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\n\"white\"\n\n\n-\n\n\nThe default colour of pixels on the waffle\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the waffle is clicked. This function MUST take either zero or two arguments, if the function takes two arguments the \nx\n and \ny\n co-ordinates of the pixel which was clicked will be given.\n\n\n\n\n\n\ndim\n\n\nint\n\n\n20\n\n\n-\n\n\nHow large one of the pixels on the waffle is\n\n\n\n\n\n\ndotty\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the pixels display as dots/circles (True) or squares (False)\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n3\n\n\n-\n\n\nSet the height in waffle pixels\n\n\n\n\n\n\npad\n\n\nint\n\n\n5\n\n\n-\n\n\nHow much space is between the pixels on the waffle\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n3\n\n\n-\n\n\nSet the width in waffle pixels\n\n\n\n\n\n\nremember\n\n\nboolean\n\n\nTrue\n\n\n-\n\n\nNo longer needed - all Waffles will now have a memory.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nNone\n\n\nNo\n\n\nIf the widget should be enabled. If \nNone\n (the default) the enabled property will be inherited from the master\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the waffle. Takes a \ncolor\n value.\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on your Waffle object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nget_all()\n\n\n-\n\n\nList\n\n\nReturns the pixel colours in the grid as a 2D list.\n\n\n\n\n\n\nget_pixel(x, y)\n\n\nx (int), y (int)\n\n\nstring\n\n\nReturns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\npixel(x, y)\n\n\n(int), y (int)\n\n\nWafflePixel\n\n\nReturns the pixel at the specified coordinates. 0,0 is the top left of the grid. \nWaffle.pixel(x,y)\n is the equivalent of \nWaffle[x,y]\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nset_all(color)\n\n\ncolor (\ncolor\n)\n\n\n-\n\n\nSets all pixels to the specified colour.\n\n\n\n\n\n\nset_pixel(x, y, color)\n\n\nx (int), y (int), color (\ncolor\n)\n\n\n-\n\n\nSets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the Waffle is clicked\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nThe default colour of pixels on the waffle\n\n\n\n\n\n\ndotty\n\n\nbool\n\n\nIf \nTrue\n the waffle will display circles\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSet the height in waffle pixels\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\npad\n\n\nint\n\n\nThe size of the padding between pixels\n\n\n\n\n\n\npixel_size\n\n\nint\n\n\nThe size of the one pixel\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSet the width in waffle pixels\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\n\n\nExample\n\n\nSet a pixel colour\n\n\nA Waffle can remember the colour of each pixel within it.\n\n\nfrom guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()\n\n\n\n\nWafflePixel\n\n\nA WafflePixel object is returned by \nWaffle.pixel(x,y)\n and \nWaffle[x,y]\n.\n\n\nfrom guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.pixel(x,y).color = \"red\"\nmy_waffle[x,y].dotty = True\n\napp.display()\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx\n\n\nint\n\n\nReturns the x position of the pixel on the widget\n\n\n\n\n\n\nx\n\n\nint\n\n\nReturns the y position of the pixel on the widget\n\n\n\n\n\n\ncanvas_x\n\n\nint\n\n\nReturns the x position of the pixel on the canvas\n\n\n\n\n\n\ncanvas_y\n\n\nint\n\n\nReturns the y position of the pixel on the canvas\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nSets or returns the color of the pixel\n\n\n\n\n\n\ndotty\n\n\nbool\n\n\nSet to \nTrue\n to make the pixel a circle\n\n\n\n\n\n\nsize\n\n\nint\n\n\nReturns the size of the pixel in \ndisplay\n pixels",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#waffle",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None, visible=True, enabled=None, bg=None)",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#what-is-it",
            "text": "The  Waffle  object display an n*n grid of squares with custom dimensions and padding",
            "title": "What is it"
        },
        {
            "location": "/waffle/#how-do-i-make-one",
            "text": "Create a  Waffle  object like this:  from guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/waffle/#starting-parameters",
            "text": "When you create a  Waffle  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  waffle = Waffle(app, height=25)     Parameter  Takes  Default  Compulsory  Description      master  App, Window or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its container. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" .    color  color  \"white\"  -  The default colour of pixels on the waffle    command  function name  None  -  The name of a function to call when the waffle is clicked. This function MUST take either zero or two arguments, if the function takes two arguments the  x  and  y  co-ordinates of the pixel which was clicked will be given.    dim  int  20  -  How large one of the pixels on the waffle is    dotty  boolean  False  -  Whether the pixels display as dots/circles (True) or squares (False)    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    height  int  3  -  Set the height in waffle pixels    pad  int  5  -  How much space is between the pixels on the waffle    width  int  3  -  Set the width in waffle pixels    remember  boolean  True  -  No longer needed - all Waffles will now have a memory.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  None  No  If the widget should be enabled. If  None  (the default) the enabled property will be inherited from the master    bg  color  None  No  The background colour of the waffle. Takes a  color  value.     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Starting parameters"
        },
        {
            "location": "/waffle/#methods",
            "text": "You can call the following methods on your Waffle object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    get_all()  -  List  Returns the pixel colours in the grid as a 2D list.    get_pixel(x, y)  x (int), y (int)  string  Returns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    pixel(x, y)  (int), y (int)  WafflePixel  Returns the pixel at the specified coordinates. 0,0 is the top left of the grid.  Waffle.pixel(x,y)  is the equivalent of  Waffle[x,y]    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    set_all(color)  color ( color )  -  Sets all pixels to the specified colour.    set_pixel(x, y, color)  x (int), y (int), color ( color )  -  Sets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.    show()  -  -  Displays the widget    update_command(command)  command (function name)  -  Updates the function to call when the Waffle is clicked",
            "title": "Methods"
        },
        {
            "location": "/waffle/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    color  color  The default colour of pixels on the waffle    dotty  bool  If  True  the waffle will display circles    enabled  boolean  True  if the widget is enabled    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Set the height in waffle pixels    master  App or Box  The container to which this widget belongs    pad  int  The size of the padding between pixels    pixel_size  int  The size of the one pixel    width  size  Set the width in waffle pixels    visible  boolean  If this widget is visible",
            "title": "Properties"
        },
        {
            "location": "/waffle/#example",
            "text": "Set a pixel colour  A Waffle can remember the colour of each pixel within it.  from guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()",
            "title": "Example"
        },
        {
            "location": "/waffle/#wafflepixel",
            "text": "A WafflePixel object is returned by  Waffle.pixel(x,y)  and  Waffle[x,y] .  from guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.pixel(x,y).color = \"red\"\nmy_waffle[x,y].dotty = True\n\napp.display()",
            "title": "WafflePixel"
        },
        {
            "location": "/waffle/#properties_1",
            "text": "You can set and get the following properties:     Method  Data type  Description      x  int  Returns the x position of the pixel on the widget    x  int  Returns the y position of the pixel on the widget    canvas_x  int  Returns the x position of the pixel on the canvas    canvas_y  int  Returns the y position of the pixel on the canvas    color  color  Sets or returns the color of the pixel    dotty  bool  Set to  True  to make the pixel a circle    size  int  Returns the size of the pixel in  display  pixels",
            "title": "Properties"
        },
        {
            "location": "/window/",
            "text": "Window\n\n\n(Contains a \ntkinter.TopLevel\n object)\n\n\n__init__(self, master, title=\"guizero\", width=500, height=500, layout=\"auto\", bg=None, visible=True):\n\n\nWhat is it?\n\n\nA \nWindow\n object is how you create new windows in guizero.\n\n\n\n\nHow do I make one?\n\n\nCreate an \nWindow\n object like this:\n\n\nfrom guizero import App, Window\napp = App()\nwindow = Window(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nWindow\n object you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets like this: \nwindow = Window(app, bg=\"red\", height=200)\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe app to which the window belongs\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the window. Takes a \ncolor\n value.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe height of the window in pixels.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\nNo\n\n\nWhether widgets pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n\"guizero\"\n\n\nNo\n\n\nThe title displayed in the bar at the top of the window.\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe width of the window in pixels.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the window should be visible.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nWindow\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables all the widgets in the window so that they cannot be interacted with\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the windows\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables all the widgets in the window\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the window\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the window from view.\n\n\n\n\n\n\non_close(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCalls the given function when the user tries to close the window.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow(wait = False)\n\n\n-\n\n\n-\n\n\nDisplays the window if it was previously hidden\n\n\n\n\n\n\nupdate()\n\n\n-\n\n\n-\n\n\nForce the window to update itself, useful if changes aren't reflected in the UI.\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the window\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the window is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font that widgets should use\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the window\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the Window (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\nThe title of the window\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text widgets should use\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text widgets should use\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf the window is visible\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the window\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nWindow\n object is called \nwindow\n you would write \nwindow.title\n.\n\n\nYou can \nset\n the property (for example \nwindow.title = \"Hello world\"\n) or \nget\n the value of the property to use (for example \nprint(window.title)\n).\n\n\nExamples\n\n\nCreating a Window object\n\n\nCreate an \nWindow\n object by calling the \nWindow()\n constructor. You should give the object a name so you can refer to it later - in this case we have called it \nwindow\n. It is best to keep the name you give to your \nWindow\n object quite short, as you will have to use it to tell other widgets where they should be stored.\n\n\nfrom guizero import App, Window\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\napp.display()\n\n\n\n\nShowing and hiding a Window\n\n\nWindow\n objects can be shown and hidden using the \nshow()\n and \nhide()\n methods:\n\n\nfrom guizero import App, Window, PushButton\n\ndef open_window():\n    window_2.show()\n\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(app, title = \"2nd Window\", height=300, width=200)\nwindow.hide()\n\nopen_button(app, text=\"open 2nd window\", command=open_window)\n\napp.display()\n\n\n\n\nIf you want a \nWindow\n to become the main window and stop all other windows responding until it is closed you can set the optional \nwait\n parameter to \nTrue\n when using \nshow\n:\n\n\ndef open_window():\n    window_2.show(wait = True)",
            "title": "Window"
        },
        {
            "location": "/window/#window",
            "text": "(Contains a  tkinter.TopLevel  object)  __init__(self, master, title=\"guizero\", width=500, height=500, layout=\"auto\", bg=None, visible=True):",
            "title": "Window"
        },
        {
            "location": "/window/#what-is-it",
            "text": "A  Window  object is how you create new windows in guizero.",
            "title": "What is it?"
        },
        {
            "location": "/window/#how-do-i-make-one",
            "text": "Create an  Window  object like this:  from guizero import App, Window\napp = App()\nwindow = Window(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/window/#starting-parameters",
            "text": "When you create a  Window  object you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets like this:  window = Window(app, bg=\"red\", height=200)     Parameter  Data type  Default  Compulsory  Description      master  App  -  Yes  The app to which the window belongs    bg  color  None  No  The background colour of the window. Takes a  color  value.    height  int  500  No  The height of the window in pixels.    layout  string  \"auto\"  No  Whether widgets pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    title  string  \"guizero\"  No  The title displayed in the bar at the top of the window.    width  int  500  No  The width of the window in pixels.    visible  boolean  True  No  If the window should be visible.",
            "title": "Starting parameters"
        },
        {
            "location": "/window/#methods",
            "text": "You can call the following methods on a  Window  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    disable()  -  -  Disables all the widgets in the window so that they cannot be interacted with    destroy()  -  -  Destroys the windows    enable()  -  -  Enables all the widgets in the window    focus()  -  -  Gives focus to the window    hide()  -  -  Hides the window from view.    on_close(command)  command (function name)  -  Calls the given function when the user tries to close the window.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show(wait = False)  -  -  Displays the window if it was previously hidden    update()  -  -  Force the window to update itself, useful if changes aren't reflected in the UI.",
            "title": "Methods"
        },
        {
            "location": "/window/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  color  The background colour of the window    enabled  boolean  True  if the window is enabled    font  string  The font that widgets should use    height  int  The height of the window    layout  string  The layout being used by the Window ( \"auto\" ) or ( \"grid\" )    title  string  The title of the window    text_size  int  The size of the text widgets should use    text_color  color  The colour of the text widgets should use    visible  boolean  If the window is visible    width  int  The width of the window     Refer to a property as  <name of widget>.property . For example, if your  Window  object is called  window  you would write  window.title .  You can  set  the property (for example  window.title = \"Hello world\" ) or  get  the value of the property to use (for example  print(window.title) ).",
            "title": "Properties"
        },
        {
            "location": "/window/#examples",
            "text": "Creating a Window object  Create an  Window  object by calling the  Window()  constructor. You should give the object a name so you can refer to it later - in this case we have called it  window . It is best to keep the name you give to your  Window  object quite short, as you will have to use it to tell other widgets where they should be stored.  from guizero import App, Window\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\napp.display()  Showing and hiding a Window  Window  objects can be shown and hidden using the  show()  and  hide()  methods:  from guizero import App, Window, PushButton\n\ndef open_window():\n    window_2.show()\n\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(app, title = \"2nd Window\", height=300, width=200)\nwindow.hide()\n\nopen_button(app, text=\"open 2nd window\", command=open_window)\n\napp.display()  If you want a  Window  to become the main window and stop all other windows responding until it is closed you can set the optional  wait  parameter to  True  when using  show :  def open_window():\n    window_2.show(wait = True)",
            "title": "Examples"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\n\nContibutions are very welcome; be that changes, bug fixing, issue resolution or support.\n\n\nIssues\n\n\nAll issues should be raise on \ngithub.com/lawsie/guizero/issues\n\n\nCode\n\n\nWhen providing code changes please:\n\n\n\n\nuse the \ndev\n branch as the base for all changes\n\n\ncreate a single pull requests for each fix / addition\n\n\nfollow the existing coding style\n\n\nprovide documentation for all changes as markdown in \n/docs-src\n\n\nprovide tests for all changes in \n/test",
            "title": "Notes"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Contibutions are very welcome; be that changes, bug fixing, issue resolution or support.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#issues",
            "text": "All issues should be raise on  github.com/lawsie/guizero/issues",
            "title": "Issues"
        },
        {
            "location": "/contributing/#code",
            "text": "When providing code changes please:   use the  dev  branch as the base for all changes  create a single pull requests for each fix / addition  follow the existing coding style  provide documentation for all changes as markdown in  /docs-src  provide tests for all changes in  /test",
            "title": "Code"
        },
        {
            "location": "/development/",
            "text": "Development\n\n\nNotes on how to develop guizero (on Windows).\n\n\nSetup\n\n\nUpgrade pip:\n\n\npython.exe -m pip install pip --upgrade\n\n\n\n\nInstall / upgrade pre-requisites:\n\n\npip install mkdocs wheel twine virtualenv pytest pillow --upgrade\n\n\n\n\nPython library\n\n\nCreate a virtual environment (not essential, but a good idea!):\n\n\nvirtualenv guizero-[versionno]\ncd guizero-[versionno]\n\n\n\n\nActivate your virtual environment:\n\n\nScripts\\activate\n\n\n\n\nCheckout and install guizero for development:\n\n\ngit clone https://github.com/lawsie/guizero\ncd guizero\ngit checkout dev\npython setup.py develop\n\n\n\n\nWhen you have finished your development, deactivate your virtual environment:\n\n\nScripts\\deactivate\n\n\n\n\nTests\n\n\nTo run the automated tests:\n\n\ncd guizero\\test\npytest -v \n\n\n\n\nIf running the tests inside a virtual environment you will need to install pytest in that virtual enviroment.\n\n\npip install pytest\n\n\n\n\nNote - tkinter can error when running the tests usually when the interpreter doesn't start properly, it doesnt seem to like being initialised and destroyed hundreds of times, I suspect a file locking issue as you dont see the problem on Linux. So sometimes you might get a test fail with an error like \nThis probably means that tk wasn't installed properly.\n. Just re-run the last failed errors! \npytest --lf -v\n\n\nDocuments\n\n\nTest documents by serving up MkDocs:\n\n\ncd guizero\\docs-src\nmkdocs serve\n\n\n\n\nOpen \nhttp://127.0.0.1:8000/",
            "title": "Developing"
        },
        {
            "location": "/development/#development",
            "text": "Notes on how to develop guizero (on Windows).",
            "title": "Development"
        },
        {
            "location": "/development/#setup",
            "text": "Upgrade pip:  python.exe -m pip install pip --upgrade  Install / upgrade pre-requisites:  pip install mkdocs wheel twine virtualenv pytest pillow --upgrade",
            "title": "Setup"
        },
        {
            "location": "/development/#python-library",
            "text": "Create a virtual environment (not essential, but a good idea!):  virtualenv guizero-[versionno]\ncd guizero-[versionno]  Activate your virtual environment:  Scripts\\activate  Checkout and install guizero for development:  git clone https://github.com/lawsie/guizero\ncd guizero\ngit checkout dev\npython setup.py develop  When you have finished your development, deactivate your virtual environment:  Scripts\\deactivate",
            "title": "Python library"
        },
        {
            "location": "/development/#tests",
            "text": "To run the automated tests:  cd guizero\\test\npytest -v   If running the tests inside a virtual environment you will need to install pytest in that virtual enviroment.  pip install pytest  Note - tkinter can error when running the tests usually when the interpreter doesn't start properly, it doesnt seem to like being initialised and destroyed hundreds of times, I suspect a file locking issue as you dont see the problem on Linux. So sometimes you might get a test fail with an error like  This probably means that tk wasn't installed properly. . Just re-run the last failed errors!  pytest --lf -v",
            "title": "Tests"
        },
        {
            "location": "/development/#documents",
            "text": "Test documents by serving up MkDocs:  cd guizero\\docs-src\nmkdocs serve  Open  http://127.0.0.1:8000/",
            "title": "Documents"
        },
        {
            "location": "/deployment/",
            "text": "Deploy\n\n\nNotes on how to deploy guizero (on Windows).\n\n\nPrepare\n\n\n\n\nUpdate version number in \nsetup.py\n\n\nUpdate version number in \nREADME.md\n\n\nUpdate release date in \nREADME.md\n\n\nUpdate version number in \ndocs-src\\docs\\about.md\n\n\nUpdate \nchangelog\n in debian packages\n\n\nUpdate \nchangelog.md\n in docs\n\n\n\n\nPython library\n\n\nInstall locally:\n\n\ncd guizero\npython setup.py install\n\n\n\n\nBuild for deployment:\n\n\ncd guizero\npython setup.py sdist\npython setup.py bdist_wheel\n\n\n\n\nUpload to pypi:\n\n\ncd guizero\ntwine upload dist/* --skip-existing\n\n\n\n\nDocuments\n\n\nBuild:\n\n\ncd guizero/docs-src\nmkdocs build\n\n\n\n\nCopy to \ndocs\n:\n\n\ncd guizero\nxcopy docs-src\\site\\* docs /E\n\n\n\n\nPromote and tag release on github\n\n\nPush all changes to \nmaster\n.\n\n\nCreate a new release on github named \n0.0.0\n.",
            "title": "Deploying"
        },
        {
            "location": "/deployment/#deploy",
            "text": "Notes on how to deploy guizero (on Windows).",
            "title": "Deploy"
        },
        {
            "location": "/deployment/#prepare",
            "text": "Update version number in  setup.py  Update version number in  README.md  Update release date in  README.md  Update version number in  docs-src\\docs\\about.md  Update  changelog  in debian packages  Update  changelog.md  in docs",
            "title": "Prepare"
        },
        {
            "location": "/deployment/#python-library",
            "text": "Install locally:  cd guizero\npython setup.py install  Build for deployment:  cd guizero\npython setup.py sdist\npython setup.py bdist_wheel  Upload to pypi:  cd guizero\ntwine upload dist/* --skip-existing",
            "title": "Python library"
        },
        {
            "location": "/deployment/#documents",
            "text": "Build:  cd guizero/docs-src\nmkdocs build  Copy to  docs :  cd guizero\nxcopy docs-src\\site\\* docs /E",
            "title": "Documents"
        },
        {
            "location": "/deployment/#promote-and-tag-release-on-github",
            "text": "Push all changes to  master .  Create a new release on github named  0.0.0 .",
            "title": "Promote and tag release on github"
        },
        {
            "location": "/changelog/",
            "text": "guizero\n\n\n0.6.0 - 2019-02-08\n\n\n\n\nRefactoring of layout functions\n\n\nEnabled \nalign\n for the \nauto\n layout\n\n\nwidth\n and \nheight\n can now be set to \n\"fill\"\n\n\nModified \nsetup.py\n to restrict install to Python 3 only\n\n\nMinor bug fixes\n\n\ncontributors \nmartinohanlon\n, \nbennuttal\n, \nyeyeto2788\n, \nknowledgejunkie\n, \nlawsie\n\n\n\n\n0.5.4 - 2018-10-16\n\n\n\n\nFixed \nBox\n to size properly\n\n\nAdded \nborder\n to \nBox\n\n\nAdded \nwidth\n and \nheight\n to widget constructor\n\n\nAdded \nresize\n method to all widgets\n\n\nMinor bug fixes\n\n\ncontributors \nmartinohanlon\n\n\n\n\n0.5.3 - 2018-07-18\n\n\n\n\nVarious bug fixes\n\n\nwrapping multiline \nTextBox\n data\n\n\nButtonGroup\n, \nComboBox\n now allow 0 options at init\n\n\nMinimum pillow version is now 4.3.0\n\n\nupdate\n method added to \nAdd\n and \nWindow\n\n\ncontributors \nmartinohanlon\n, \nscotty3785\n, \nMrYsLab\n, \nbsimmo\n\n\n\n\n0.5.2 - 2018-06-01\n\n\n\n\nRefactoring of \nButtonGroup\n, including API breaking change - if no hidden values are specified, \nButtonGroup.value\n now returns the text value not a generate string number \n#178\n\n\nA widgets properties \nbg\n, \ntext_color\n, \ntext_size\n, \nfont\n, \nwidth\n, \nheight\n can be restored by to their default by setting them to \nNone\n \n#181\n\n\nSlider is now sized properly when orientated vertically \n#186\n\n\nCombo\n and \nButtonGroup\n now support \nappend\n, \ninsert\n, \nremove\n, \nclear\n and depreciated \nadd_option\n \n#180\n\n\nRefactoring of class hierarchy \n\n\nVarious bug fixes\n\n\ncontributors \nmartinohanlon\n\n\n\n\n0.5.1 - 2018-05-14\n\n\n\n\nApp\n, \nWindow\n, \nBox\n now support the following properties and will cascade them to widgets within them:\n\n\nbg\n\n\ntext_color\n\n\ntext_size\n\n\nfont\n\n\nenabled\n\n\n\n\n\n\nIntroduced \nListBox\n\n\nBug fixes relating to \nbg\n and \ntext_color\n causing widgets to change colour when selected\n\n\nMinor bug fixes with \nCheckBox\n, \nWaffle\n and \nCombo\n\n\nDocumentation fixes and updates\n\n\ncontributors to this release \nmartinohanlon\n, \nlawsie\n, \nHarlekuin\n\n\n\n\n0.5.0 - 2018-04-10\n\n\n\n\nv0.5.0 includes significant refactoring of the guizero code base and introduces many new features\n\n\nNew image functionality introduced when PIL is installed:\n\n\nimages can be passed as \nTk.PhotoImage\n or \nPIL.Image\n objects as well as file paths\n\n\nmore images types are supported\n\n\nanimated images (gifs) are supported\n\n\nimages are scaled when the size is changed\n\n\n\n\n\n\nButtonGroup\n - \nselected\n is now optional, \nenabled\n properties now supported, \nvalue_text\n fixed\n\n\nFixed multiple \nApp\n bug\n\n\nCreated \nWindow\n class to support multi-window applications\n\n\nAdded \nmultiline\n and \nscrollbar\n functionality to \nTextBox\n\n\nRefactored guizero to introduce a class hierarchy making guizero wide code changes easier to implement\n\n\nAdded the following events to all widgets, this should be considered experimental in this release:\n\n\nwhen_clicked\n\n\nwhen_left_button_pressed\n\n\nwhen_left_button_released\n\n\nwhen_right_button_pressed\n\n\nwhen_right_button_released\n\n\nwhen_key_pressed\n\n\nwhen_key_released\n\n\nwhen_mouse_enters\n\n\nwhen_mouse_leaves\n\n\nwhen_mouse_dragged\n\n\n\n\n\n\nVarious minor bug fixes\n\n\nAutomated tests have been introduced\n\n\ncontributors to this release \nmartinohanlon\n, \nscotty3785\n, \nIDF31\n, \ndrussell1974\n  - ta very much :)\n\n\n\n\n0.4.5 - 2018-03-04\n\n\n\n\ncolors can now be specified as either \n\"red\"\n, \n\"#ffffff\"\n, or \n(red, green, blue)\n \n\n\nchange \nPicture\n \nimage\n startup parameter to be optional\n\n\nupdated \nPicture\n and \nPushButton\n errors and docs to show that PNG and GIF images can be used in Windows & Linux\n\n\nrefactored \nWaffle\n resolving bugs that setting properties didnt change its appearance\n\n\nchanged waffle so you can reference a pixel using \nwaffle[x,y]\n\n\nadded \ntext_color\n, \ntext_size\n and \nfont\n properties to \nSlider\n\n\nadded \nwidth\n and \nheight\n properties to:\n\n\nBox\n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPicture\n\n\nSlider\n\n\nText\n\n\n\n\n\n\nadded \nwidth\n property to:\n\n\nTextBox\n\n\n\n\n\n\ncontributors to this release \nCoal0\n, \nmartinohanlon\n, \nscotty3785\n - :)\n\n\n\n\n0.4.4 - 2018-02-12\n\n\n\n\nmade \nPushButton\n \ncommand\n optional\n\n\nCombo\n command functions can now have 0 arguments\n\n\nWaffle\n command functions can now have 0 arguments\n\n\nrefactored command functions and added \nupdate_command\n to: \n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPushButton\n\n\nSlider\n\n\nWaffle\n\n\n\n\n\n\nrefactored \ntext_color\n, \ntext_size\n and \nfont\n properties and added them to:\n\n\nButtonGroup\n\n\nCombo\n\n\nCheckBox\n\n\nPushButton\n\n\nText\n\n\nTextBox\n\n\n\n\n\n\nrefactored \nbg\n (background) and added to:\n\n\nBox\n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPicture\n\n\nPushButton\n\n\nSlider\n\n\nText\n\n\nTextBox\n\n\n\n\n\n\ncontributors to this release \nm4ddav3\n, \nCoal0\n, \nlawsie\n, \nmartinohanlon\n - :)\n\n\n\n\n0.4.3 - 2018-01-10\n\n\nMinor features, bug fixes and internal refactoring\n\n\n\n\nadded \nxspan\n, \nyspan\n to grid layout (Credit: \npenguintutor\n)\n\n\nfixed \nshow()\n for widgets in a grid layout\n\n\nadded \nmaster\n, \ngrid\n, \nalign\n and \nvisible\n properties to widgets\n\n\nadded \nlayout\n property to containers\n\n\nfixed \nWaffle\n \nheight\n (Credit: \nscotty3785\n)\n\n\nminor doc updates\n\n\n0.4.2 was never released due to some pypi / wheel problems\n\n\n\n\n0.4.1 - 2017-12-28\n\n\nBug fixes and deployment test\n\n\n\n\nPushButton bug fixes\n\n\nadded \nenabled\n property to widgets which support \nEnable\n / \nDisable\n\n\ndocumentation tidy up\n\n\nadded build notes to documentation\n\n\n\n\n0.4 - 2017-12-19\n\n\nThank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version:\n\nbcroston\n, \nbennuttall\n, \nCoal0\n,  \nmartinohanlon\n and  \nscotty3785\n\n\nI am also very pleased to announce that \nmartinohanlon\n has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.\n\n\nGeneral changes:\n\n\n\n\nAll classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as \nObject.tk.tkmethod()\n (Credit for idea: \nbennuttall\n)\n\n\nImproved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea: \nbennuttall\n)\n\n\n[Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!) \nThis fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.\n\n\nAll classes now inherit from mixins, adding 9 new common methods usable on most widgets - \nafter()\n, \ncancel()\n, \ndestroy()\n, \ndisable()\n, \nenable()\n, \nfocus()\n, \nhide()\n, \nshow()\n, \nrepeat()\n,  (Credit: \nCoal0\n and \nmartinohanlon\n)\n\n\nThe new \nrepeat()\n method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.\n\n\nDocumentation and examples have been improved and updated\n\n\n\n\nApp:\n\n\n\n\nNew constructor argument \nbg\n replaces deprecated \nbgcolor\n argument. If both are specified, \nbg\n overrides \nbgcolor\n.\n\n\nset_title()\n and \nbgcolor()\n methods are now deprecated and have been replaced by \ntitle\n and \nbg\n properties\n\n\nNew additional properties \nwidth\n and \nheight\n\n\n\n\nButtonGroup:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\nNew \nvalue_text\n property to get the text associated with the selected option\n\n\n\n\nCheckBox:\n\n\n\n\nget_text()\n, \nget_value()\n and \nchange_text()\n methods are now deprecated and have been replaced by the \nvalue\n and \ntext\n properties\n\n\nNew \ntoggle()\n method added\n\n\n\n\nCombo:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\n[Bug fix] \nset_default()\n now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option\n\n\n\n\nPicture:\n\n\n\n\nset()\n method is now deprecated and has been replaced by the \nvalue\n property\n\n\n\n\nPushButton:\n\n\n\n\nset_text()\n method is now deprecated and has been replaced by the \ntext\n property\n\n\nNew properties for \ntext_color\n, \nbg\n, \nfont\n, \ntext_size\n, \nheight\n and \nwidth\n \u2013 make your buttons look pretty!\n\n\nFind out whether a button is pressed (1) or released (0) with the new \nvalue\n property\n\n\nNew \nicon()\n method to set the icon of a button after it is created\n\n\ntoggle_state()\n method deprecated and renamed to \ntoggle()\n for consistency\n\n\n\n\nSlider:\n\n\n\n\nNew \nvalue\n property for getting and setting the value of the slider\n\n\n\n\nText:\n\n\n\n\nNew constructor arguments \ntext_color\n and \nbg\n\n\ncolor\n constructor argument now deprecated and replaced by \ntext_color\n. If both are specified, \ntext_color\n overrides \ncolor\n.\n\n\nget()\n, \nset()\n, \ncolor()\n, \nfont_face()\n and \nfont_size()\n methods are now deprecated, replaced by properties \nvalue\n, \ntext_color\n, \nbg\n, \nfont\n and \nsize\n\n\n\n\nTextBox:\n\n\n\n\nget()\n and \nset()\n methods now deprecated and replaced by \nvalue\n property\n\n\n\n\nWaffle:\n\n\n\n\nAll waffles will now have a memory. The \nremember\n constructor argument remains for backwards compatibility only \nand will be removed in a future release\n.\n\n\nYou can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit: \nscotty3785\n)\n\n\nChanged internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit: \nscotty3785\n)",
            "title": "Change log"
        },
        {
            "location": "/changelog/#guizero",
            "text": "",
            "title": "guizero"
        },
        {
            "location": "/changelog/#060-2019-02-08",
            "text": "Refactoring of layout functions  Enabled  align  for the  auto  layout  width  and  height  can now be set to  \"fill\"  Modified  setup.py  to restrict install to Python 3 only  Minor bug fixes  contributors  martinohanlon ,  bennuttal ,  yeyeto2788 ,  knowledgejunkie ,  lawsie",
            "title": "0.6.0 - 2019-02-08"
        },
        {
            "location": "/changelog/#054-2018-10-16",
            "text": "Fixed  Box  to size properly  Added  border  to  Box  Added  width  and  height  to widget constructor  Added  resize  method to all widgets  Minor bug fixes  contributors  martinohanlon",
            "title": "0.5.4 - 2018-10-16"
        },
        {
            "location": "/changelog/#053-2018-07-18",
            "text": "Various bug fixes  wrapping multiline  TextBox  data  ButtonGroup ,  ComboBox  now allow 0 options at init  Minimum pillow version is now 4.3.0  update  method added to  Add  and  Window  contributors  martinohanlon ,  scotty3785 ,  MrYsLab ,  bsimmo",
            "title": "0.5.3 - 2018-07-18"
        },
        {
            "location": "/changelog/#052-2018-06-01",
            "text": "Refactoring of  ButtonGroup , including API breaking change - if no hidden values are specified,  ButtonGroup.value  now returns the text value not a generate string number  #178  A widgets properties  bg ,  text_color ,  text_size ,  font ,  width ,  height  can be restored by to their default by setting them to  None   #181  Slider is now sized properly when orientated vertically  #186  Combo  and  ButtonGroup  now support  append ,  insert ,  remove ,  clear  and depreciated  add_option   #180  Refactoring of class hierarchy   Various bug fixes  contributors  martinohanlon",
            "title": "0.5.2 - 2018-06-01"
        },
        {
            "location": "/changelog/#051-2018-05-14",
            "text": "App ,  Window ,  Box  now support the following properties and will cascade them to widgets within them:  bg  text_color  text_size  font  enabled    Introduced  ListBox  Bug fixes relating to  bg  and  text_color  causing widgets to change colour when selected  Minor bug fixes with  CheckBox ,  Waffle  and  Combo  Documentation fixes and updates  contributors to this release  martinohanlon ,  lawsie ,  Harlekuin",
            "title": "0.5.1 - 2018-05-14"
        },
        {
            "location": "/changelog/#050-2018-04-10",
            "text": "v0.5.0 includes significant refactoring of the guizero code base and introduces many new features  New image functionality introduced when PIL is installed:  images can be passed as  Tk.PhotoImage  or  PIL.Image  objects as well as file paths  more images types are supported  animated images (gifs) are supported  images are scaled when the size is changed    ButtonGroup  -  selected  is now optional,  enabled  properties now supported,  value_text  fixed  Fixed multiple  App  bug  Created  Window  class to support multi-window applications  Added  multiline  and  scrollbar  functionality to  TextBox  Refactored guizero to introduce a class hierarchy making guizero wide code changes easier to implement  Added the following events to all widgets, this should be considered experimental in this release:  when_clicked  when_left_button_pressed  when_left_button_released  when_right_button_pressed  when_right_button_released  when_key_pressed  when_key_released  when_mouse_enters  when_mouse_leaves  when_mouse_dragged    Various minor bug fixes  Automated tests have been introduced  contributors to this release  martinohanlon ,  scotty3785 ,  IDF31 ,  drussell1974   - ta very much :)",
            "title": "0.5.0 - 2018-04-10"
        },
        {
            "location": "/changelog/#045-2018-03-04",
            "text": "colors can now be specified as either  \"red\" ,  \"#ffffff\" , or  (red, green, blue)    change  Picture   image  startup parameter to be optional  updated  Picture  and  PushButton  errors and docs to show that PNG and GIF images can be used in Windows & Linux  refactored  Waffle  resolving bugs that setting properties didnt change its appearance  changed waffle so you can reference a pixel using  waffle[x,y]  added  text_color ,  text_size  and  font  properties to  Slider  added  width  and  height  properties to:  Box  ButtonGroup  CheckBox  Combo  Picture  Slider  Text    added  width  property to:  TextBox    contributors to this release  Coal0 ,  martinohanlon ,  scotty3785  - :)",
            "title": "0.4.5 - 2018-03-04"
        },
        {
            "location": "/changelog/#044-2018-02-12",
            "text": "made  PushButton   command  optional  Combo  command functions can now have 0 arguments  Waffle  command functions can now have 0 arguments  refactored command functions and added  update_command  to:   ButtonGroup  CheckBox  Combo  PushButton  Slider  Waffle    refactored  text_color ,  text_size  and  font  properties and added them to:  ButtonGroup  Combo  CheckBox  PushButton  Text  TextBox    refactored  bg  (background) and added to:  Box  ButtonGroup  CheckBox  Combo  Picture  PushButton  Slider  Text  TextBox    contributors to this release  m4ddav3 ,  Coal0 ,  lawsie ,  martinohanlon  - :)",
            "title": "0.4.4 - 2018-02-12"
        },
        {
            "location": "/changelog/#043-2018-01-10",
            "text": "Minor features, bug fixes and internal refactoring   added  xspan ,  yspan  to grid layout (Credit:  penguintutor )  fixed  show()  for widgets in a grid layout  added  master ,  grid ,  align  and  visible  properties to widgets  added  layout  property to containers  fixed  Waffle   height  (Credit:  scotty3785 )  minor doc updates  0.4.2 was never released due to some pypi / wheel problems",
            "title": "0.4.3 - 2018-01-10"
        },
        {
            "location": "/changelog/#041-2017-12-28",
            "text": "Bug fixes and deployment test   PushButton bug fixes  added  enabled  property to widgets which support  Enable  /  Disable  documentation tidy up  added build notes to documentation",
            "title": "0.4.1 - 2017-12-28"
        },
        {
            "location": "/changelog/#04-2017-12-19",
            "text": "Thank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version: bcroston ,  bennuttall ,  Coal0 ,   martinohanlon  and   scotty3785  I am also very pleased to announce that  martinohanlon  has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.  General changes:   All classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as  Object.tk.tkmethod()  (Credit for idea:  bennuttall )  Improved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea:  bennuttall )  [Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!)  This fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.  All classes now inherit from mixins, adding 9 new common methods usable on most widgets -  after() ,  cancel() ,  destroy() ,  disable() ,  enable() ,  focus() ,  hide() ,  show() ,  repeat() ,  (Credit:  Coal0  and  martinohanlon )  The new  repeat()  method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.  Documentation and examples have been improved and updated   App:   New constructor argument  bg  replaces deprecated  bgcolor  argument. If both are specified,  bg  overrides  bgcolor .  set_title()  and  bgcolor()  methods are now deprecated and have been replaced by  title  and  bg  properties  New additional properties  width  and  height   ButtonGroup:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  New  value_text  property to get the text associated with the selected option   CheckBox:   get_text() ,  get_value()  and  change_text()  methods are now deprecated and have been replaced by the  value  and  text  properties  New  toggle()  method added   Combo:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  [Bug fix]  set_default()  now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option   Picture:   set()  method is now deprecated and has been replaced by the  value  property   PushButton:   set_text()  method is now deprecated and has been replaced by the  text  property  New properties for  text_color ,  bg ,  font ,  text_size ,  height  and  width  \u2013 make your buttons look pretty!  Find out whether a button is pressed (1) or released (0) with the new  value  property  New  icon()  method to set the icon of a button after it is created  toggle_state()  method deprecated and renamed to  toggle()  for consistency   Slider:   New  value  property for getting and setting the value of the slider   Text:   New constructor arguments  text_color  and  bg  color  constructor argument now deprecated and replaced by  text_color . If both are specified,  text_color  overrides  color .  get() ,  set() ,  color() ,  font_face()  and  font_size()  methods are now deprecated, replaced by properties  value ,  text_color ,  bg ,  font  and  size   TextBox:   get()  and  set()  methods now deprecated and replaced by  value  property   Waffle:   All waffles will now have a memory. The  remember  constructor argument remains for backwards compatibility only  and will be removed in a future release .  You can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit:  scotty3785 )  Changed internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit:  scotty3785 )",
            "title": "0.4 - 2017-12-19"
        }
    ]
}